# 2478. Number of Beautiful Partitions

- Difficulty: Hard.
- Related Topics: String, Dynamic Programming.
- Similar Questions: Restore The Array, Number of Ways to Separate Numbers.

## Problem

You are given a string ```s``` that consists of the digits ```'1'``` to ```'9'``` and two integers ```k``` and ```minLength```.

A partition of ```s``` is called **beautiful** if:


	
- ```s``` is partitioned into ```k``` non-intersecting substrings.
	
- Each substring has a length of **at least** ```minLength```.
	
- Each substring starts with a **prime** digit and ends with a **non-prime** digit. Prime digits are ```'2'```, ```'3'```, ```'5'```, and ```'7'```, and the rest of the digits are non-prime.


Return** the number of **beautiful** partitions of **```s```. Since the answer may be very large, return it **modulo** ```109 + 7```.

A **substring** is a contiguous sequence of characters within a string.

 
**Example 1:**

```
Input: s = "23542185131", k = 3, minLength = 2
Output: 3
Explanation: There exists three ways to create a beautiful partition:
"2354 | 218 | 5131"
"2354 | 21851 | 31"
"2354218 | 51 | 31"
```

**Example 2:**

```
Input: s = "23542185131", k = 3, minLength = 3
Output: 1
Explanation: There exists one way to create a beautiful partition: "2354 | 218 | 5131".
```

**Example 3:**

```
Input: s = "3312958", k = 3, minLength = 1
Output: 1
Explanation: There exists one way to create a beautiful partition: "331 | 29 | 58".
```

 
**Constraints:**


	
- ```1 <= k, minLength <= s.length <= 1000```
	
- ```s``` consists of the digits ```'1'``` to ```'9'```.



## Solution (Java)

```java
class Solution {
	private final static int MOD = 1_000_000_007;

	public int beautifulPartitions(String s, int k, int minLength) {
		int n = s.length();
		if (!isPrime(s.charAt(0)) || isPrime(s.charAt(n - 1))) return 0;

		int[][] dp = new int[k][n];
		Arrays.fill(dp[0], 1);
		for (int i = 1; i < k; i++) {
			for (int j = 1; j < n; j++) {
				if (j - 0 >= minLength && n - j >= minLength 
					&& !isPrime(s.charAt(j - 1)) && isPrime(s.charAt(j))) {
					// can cut here.
					// dp[i][j] = no cut + cut.
					dp[i][j] = (dp[i][j - 1] + dp[i - 1][j - minLength]) % MOD;
				} else {
					dp[i][j] = dp[i][j - 1];    // no cut here.
				}
			}
		}

		return dp[k - 1][n - 1];
	}

	private boolean isPrime(char ch) {
		return ch == '2' || ch == '3' || ch == '5' || ch == '7';
	}
}
```

**Explain:**

nope.

**Complexity:**

* Time complexity : O(n).
* Space complexity : O(n).
