<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Parse Lisp Expression - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>736. Parse Lisp Expression</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/hash-table">Hash Table</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/string">String</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/stack">Stack</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/recursion">Recursion</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/ternary-expression-parser.html">Ternary Expression Parser</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/number-of-atoms.html">Number of Atoms</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/basic-calculator-iv.html">Basic Calculator IV</a></li></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>You are given a string expression representing a Lisp-like expression to return the integer value of.</p>
<p>The syntax for these expressions is given as follows.</p>
<ul>
<li><p>An expression is either an integer, let expression, add expression, mult expression, or an assigned variable. Expressions always evaluate to a single integer.</p></li>
<li><p>(An integer could be positive or negative.)</p></li>
<li><p>A let expression takes the form <code>"(let v1 e1 v2 e2 ... vn en expr)"</code>, where let is always the string <code>"let"</code>, then there are one or more pairs of alternating variables and expressions, meaning that the first variable <code>v1</code> is assigned the value of the expression <code>e1</code>, the second variable <code>v2</code> is assigned the value of the expression <code>e2</code>, and so on sequentially; and then the value of this let expression is the value of the expression <code>expr</code>.</p></li>
<li><p>An add expression takes the form <code>"(add e1 e2)"</code> where add is always the string <code>"add"</code>, there are always two expressions <code>e1</code>, <code>e2</code> and the result is the addition of the evaluation of <code>e1</code> and the evaluation of <code>e2</code>.</p></li>
<li><p>A mult expression takes the form <code>"(mult e1 e2)"</code> where mult is always the string <code>"mult"</code>, there are always two expressions <code>e1</code>, <code>e2</code> and the result is the multiplication of the evaluation of e1 and the evaluation of e2.</p></li>
<li><p>For this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally, for your convenience, the names <code>"add"</code>, <code>"let"</code>, and <code>"mult"</code> are protected and will never be used as variable names.</p></li>
<li><p>Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on the scope.</p></li>
</ul>
<p>&nbsp;
<strong>Example 1:</strong></p>
<pre><code class="hljs">Input: expression = <span class="hljs-string">"(let x 2 (mult x (let x 3 y 4 (add x y))))"</span>
Output: <span class="hljs-number">14</span>
Explanation: In <span class="hljs-keyword">the</span> expression (<span class="hljs-built_in">add</span> x y), when checking <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">value</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">variable</span> x,
we check <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> innermost scope <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> outermost <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> context <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">variable</span> we are trying <span class="hljs-built_in">to</span> evaluate.
Since x = <span class="hljs-number">3</span> is found <span class="hljs-keyword">first</span>, <span class="hljs-keyword">the</span> <span class="hljs-built_in">value</span> <span class="hljs-keyword">of</span> x is <span class="hljs-number">3.</span>
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code class="hljs">Inpu<span class="hljs-variable">t:</span> expression = <span class="hljs-string">"(let x 3 x 2 x)"</span>
Outpu<span class="hljs-variable">t:</span> <span class="hljs-number">2</span>
Explanation: Assignment in <span class="hljs-keyword">let</span> statements <span class="hljs-keyword">is</span> processed sequentially.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code class="hljs"><span class="hljs-meta">Input</span>: expression = <span class="hljs-string">"(let x 1 y 2 x (add x y) (add x y))"</span>
<span class="hljs-meta">Output</span>: 5
Explanation: The first (<span class="hljs-meta">add</span> <span class="hljs-meta">x</span> y) evaluates <span class="hljs-meta">as</span> 3, <span class="hljs-meta">and</span> is assigned to <span class="hljs-meta">x</span>.
The second (<span class="hljs-meta">add</span> <span class="hljs-meta">x</span> y) evaluates <span class="hljs-meta">as</span> 3+2 = 5.
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>1 &lt;= expression.length &lt;= 2000</code></p></li>
<li><p>There are no leading or trailing spaces in <code>expression</code>.</p></li>
<li><p>All tokens are separated by a single space in <code>expression</code>.</p></li>
<li><p>The answer and all intermediate calculations of that answer are guaranteed to fit in a <strong>32-bit</strong> integer.</p></li>
<li><p>The expression is guaranteed to be legal and evaluate to an integer.</p></li>
</ul>
<h2 id="solution-java">Solution (Java)</h2>
<pre><code class="hljs lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exp</span> </span>{
        Deque&lt;Exp&gt; exps;
        String op;
        Exp parent;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Exp</span><span class="hljs-params">(Exp from)</span> </span>{
            <span class="hljs-keyword">this</span>.exps = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
            <span class="hljs-keyword">this</span>.parent = from;
        }

        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">evaluate</span><span class="hljs-params">(Map&lt;String, Integer&gt; vars)</span> </span>{
            <span class="hljs-keyword">if</span> (op.equalsIgnoreCase(<span class="hljs-string">"add"</span>)) {
                <span class="hljs-keyword">return</span> exps.pop().evaluate(vars) + exps.pop().evaluate(vars);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op.equalsIgnoreCase(<span class="hljs-string">"mult"</span>)) {
                <span class="hljs-keyword">return</span> exps.pop().evaluate(vars) * exps.pop().evaluate(vars);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op.equalsIgnoreCase(<span class="hljs-string">"let"</span>)) {
                Map&lt;String, Integer&gt; nextVars = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(vars);
                <span class="hljs-keyword">while</span> (exps.size() &gt; <span class="hljs-number">1</span>) {
                    String varName = exps.pop().op;
                    <span class="hljs-keyword">int</span> val = exps.pop().evaluate(nextVars);
                    nextVars.put(varName, val);
                }
                <span class="hljs-keyword">return</span> exps.pop().evaluate(nextVars);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (Character.isLetter(op.charAt(<span class="hljs-number">0</span>))) {
                    <span class="hljs-keyword">return</span> vars.get(op);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> Integer.parseInt(op);
                }
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> Exp <span class="hljs-title">buildTree</span><span class="hljs-params">(String exp)</span> </span>{
        Exp root = <span class="hljs-keyword">new</span> Exp(<span class="hljs-keyword">null</span>);
        Exp cur = root;
        <span class="hljs-keyword">int</span> n = exp.length() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (n &gt;= <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">char</span> c = exp.charAt(n);
            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">')'</span>) {
                Exp next = <span class="hljs-keyword">new</span> Exp(cur);
                cur.exps.push(next);
                cur = next;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'('</span>) {
                cur.op = cur.exps.pop().op;
                cur = cur.parent;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c != <span class="hljs-string">' '</span>) {
                <span class="hljs-keyword">int</span> pre = n;
                <span class="hljs-keyword">while</span> (pre &gt;= <span class="hljs-number">0</span> &amp;&amp; exp.charAt(pre) != <span class="hljs-string">'('</span> &amp;&amp; exp.charAt(pre) != <span class="hljs-string">' '</span>) {
                    pre--;
                }
                Exp next = <span class="hljs-keyword">new</span> Exp(cur);
                next.op = exp.substring(pre + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>);
                cur.exps.push(next);
                n = pre + <span class="hljs-number">1</span>;
            }
            n--;
        }
        <span class="hljs-keyword">return</span> root.exps.pop();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">evaluate</span><span class="hljs-params">(String exp)</span> </span>{
        <span class="hljs-keyword">return</span> buildTree(exp).evaluate(<span class="hljs-keyword">new</span> HashMap&lt;&gt;());
    }
}
</code></pre>
<h2 id="solution-c">Solution (C++)</h2>
<pre><code class="hljs lang-cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">evaluate</span><span class="hljs-params">(<span class="hljs-built_in">string</span> expression)</span> </span>{        
        scopes_.clear();
        <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> eval(expression, pos);
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">int</span>&amp; pos)</span> </span>{
        scopes_.push_front(<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;());
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>; <span class="hljs-comment">// The return value of current expr        </span>
        <span class="hljs-keyword">if</span> (s[pos] == <span class="hljs-string">'('</span>) ++pos;

        <span class="hljs-comment">// command, variable or number</span>
        <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> token = getToken(s, pos);

        <span class="hljs-keyword">if</span> (token == <span class="hljs-string">"add"</span>) {
            <span class="hljs-keyword">int</span> v1 = eval(s, ++pos);
            <span class="hljs-keyword">int</span> v2 = eval(s, ++pos);
            value = v1 + v2;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (token == <span class="hljs-string">"mult"</span>) {
            <span class="hljs-keyword">int</span> v1 = eval(s, ++pos);
            <span class="hljs-keyword">int</span> v2 = eval(s, ++pos);
            value = v1 * v2;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (token == <span class="hljs-string">"let"</span>) {
            <span class="hljs-built_in">string</span> var;
            <span class="hljs-comment">// expecting " var1 exp1 var2 exp2 ... last_expr)"</span>
            <span class="hljs-keyword">while</span> (s[pos] != <span class="hljs-string">')'</span>) {
                ++pos;
                <span class="hljs-comment">// Must be last_expr</span>
                <span class="hljs-keyword">if</span> (s[pos] == <span class="hljs-string">'('</span>) {
                    value = eval(s, ++pos);
                    <span class="hljs-keyword">break</span>;
                }                
                <span class="hljs-comment">// Get a token, could be "x" or "-12" for last_expr</span>
                var = getToken(s, pos);                
                <span class="hljs-comment">// End of let, var is last_expr</span>
                <span class="hljs-keyword">if</span> (s[pos] == <span class="hljs-string">')'</span>) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isalpha</span>(var[<span class="hljs-number">0</span>]))
                        value = getValue(var);
                    <span class="hljs-keyword">else</span>
                        value = stoi(var);
                    <span class="hljs-keyword">break</span>;
                }
                <span class="hljs-comment">// x -12 -&gt; set x to -12 and store in the current scope and take it as the current return value</span>
                value = scopes_.front()[var] = eval(s, ++pos);
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isalpha</span>(token[<span class="hljs-number">0</span>])) {            
            value = getValue(token); <span class="hljs-comment">// symbol</span>
        } <span class="hljs-keyword">else</span> {            
            value = <span class="hljs-built_in">std</span>::stoi(token); <span class="hljs-comment">// number</span>
        }
        <span class="hljs-keyword">if</span> (s[pos] == <span class="hljs-string">')'</span>) ++pos;        
        scopes_.pop_front();        
        <span class="hljs-keyword">return</span> value;
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; symbol)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; scope : scopes_)        
            <span class="hljs-keyword">if</span> (scope.count(symbol)) <span class="hljs-keyword">return</span> scope.at(symbol);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// Get a token from current pos.</span>
    <span class="hljs-comment">// "let x" -&gt; "let"</span>
    <span class="hljs-comment">// "-12 (add x y)" -&gt; "-12"</span>
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">getToken</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">int</span>&amp; pos)</span> </span>{        
        <span class="hljs-built_in">string</span> token;
        <span class="hljs-keyword">while</span> (pos &lt; s.length()) {            
            <span class="hljs-keyword">if</span> (s[pos] == <span class="hljs-string">')'</span> || s[pos] == <span class="hljs-string">' '</span>) <span class="hljs-keyword">break</span>;
            token += s[pos++];
        }
        <span class="hljs-keyword">return</span> token;
    }

    <span class="hljs-built_in">deque</span>&lt;<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&gt; scopes_; 
};
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>