<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Vertical Order Traversal of a Binary Tree - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>987. Vertical Order Traversal of a Binary Tree</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/hash-table">Hash Table</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/tree">Tree</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/depth-first-search">Depth-First Search</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/breadth-first-search">Breadth-First Search</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/binary-tree">Binary Tree</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>Given the <code>root</code> of a binary tree, calculate the <strong>vertical order traversal</strong> of the binary tree.</p>
<p>For each node at position <code>(row, col)</code>, its left and right children will be at positions <code>(row + 1, col - 1)</code> and <code>(row + 1, col + 1)</code> respectively. The root of the tree is at <code>(0, 0)</code>.</p>
<p>The <strong>vertical order traversal</strong> of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.</p>
<p>Return **the *<em>vertical order traversal</em>* of the binary tree**.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg" alt="" /></p>
<pre><code class="hljs">Input: root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]
Output: [[<span class="hljs-number">9</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">15</span>],[<span class="hljs-number">20</span>],[<span class="hljs-number">7</span>]]
Explanation:
Column <span class="hljs-number">-1</span>: Only node <span class="hljs-number">9</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span> column.
Column <span class="hljs-number">0</span>: Nodes <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">15</span> are <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span> column <span class="hljs-keyword">in</span> that order <span class="hljs-keyword">from</span> top to bottom.
Column <span class="hljs-number">1</span>: Only node <span class="hljs-number">20</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span> column.
Column <span class="hljs-number">2</span>: Only node <span class="hljs-number">7</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span> column.
</code></pre>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg" alt="" /></p>
<pre><code class="hljs">Input: root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]
Output: [[<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">3</span>],[<span class="hljs-number">7</span>]]
Explanation:
Column <span class="hljs-number">-2</span>: Only node <span class="hljs-number">4</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span> column.
Column <span class="hljs-number">-1</span>: Only node <span class="hljs-number">2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span> column.
Column <span class="hljs-number">0</span>: Nodes <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-keyword">and</span> <span class="hljs-number">6</span> are <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span> column.
          <span class="hljs-number">1</span> <span class="hljs-keyword">is</span> at the top, so it comes first.
          <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> <span class="hljs-number">6</span> are at the same position (<span class="hljs-number">2</span>, <span class="hljs-number">0</span>), so we order them by their value, <span class="hljs-number">5</span> before <span class="hljs-number">6.</span>
Column <span class="hljs-number">1</span>: Only node <span class="hljs-number">3</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span> column.
Column <span class="hljs-number">2</span>: Only node <span class="hljs-number">7</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span> column.
</code></pre>
<p><strong>Example 3:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg" alt="" /></p>
<pre><code class="hljs">Input: root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]
Output: [[<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">3</span>],[<span class="hljs-number">7</span>]]
Explanation:
This <span class="hljs-keyword">case</span> <span class="hljs-keyword">is</span> the exact same as example <span class="hljs-number">2</span>, but with nodes <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> <span class="hljs-number">6</span> swapped.
Note that the solution remains the same since <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> <span class="hljs-number">6</span> are <span class="hljs-keyword">in</span> the same location <span class="hljs-keyword">and</span> should be ordered by their values.
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</p></li>
<li><p><code>0 &lt;= Node.val &lt;= 1000</code></p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-java"><span class="hljs-comment">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>{
        <span class="hljs-keyword">int</span> row;
        <span class="hljs-keyword">int</span> val;

        Node(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> val) {
            <span class="hljs-keyword">this</span>.row = row;
            <span class="hljs-keyword">this</span>.val = val;
        }
    }

    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) {
        TreeMap&lt;Integer, Queue&lt;Node&gt;&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();
        helper(root, map, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Queue&lt;Node&gt;&gt; entry : map.entrySet()) {
            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
            ret.add(list);
            Queue&lt;Node&gt; q = entry.getValue();
            <span class="hljs-keyword">while</span> (!q.isEmpty()) {
                list.add(q.poll().val);
            }
        }
        <span class="hljs-keyword">return</span> ret;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode cur, TreeMap&lt;Integer, Queue&lt;Node&gt;&gt; map, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span> </span>{
        <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span>;
        }
        map.putIfAbsent(
                c, <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a.row != b.row ? a.row - b.row : a.val - b.val));
        map.get(c).add(<span class="hljs-keyword">new</span> Node(r, cur.val));
        helper(cur.left, map, r + <span class="hljs-number">1</span>, c - <span class="hljs-number">1</span>);
        helper(cur.right, map, r + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span>);
    }
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>