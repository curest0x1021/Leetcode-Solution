<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Longest Increasing Path in a Matrix - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://baffinlee.com/leetcode-javascript/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://baffinlee.com/leetcode-javascript/static/css/app.css"/></head><body><header><h1>329. Longest Increasing Path in a Matrix</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://baffinlee.com/leetcode-javascript/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://baffinlee.com/leetcode-javascript/tag/array">Array</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/dynamic-programming">Dynamic Programming</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/depth-first-search">Depth-First Search</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/breadth-first-search">Breadth-First Search</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/graph">Graph</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/topological-sort">Topological Sort</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/memoization">Memoization</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/matrix">Matrix</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"><li><a href="https://baffinlee.com/leetcode-javascript/problem/number-of-increasing-paths-in-a-grid.html">Number of Increasing Paths in a Grid</a></li></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>Given an <code>m x n</code> integers <code>matrix</code>, return **the length of the longest increasing path in **<code>matrix</code>.</p>
<p>From each cell, you can either move in four directions: left, right, up, or down. You <strong>may not</strong> move <strong>diagonally</strong> or move <strong>outside the boundary</strong> (i.e., wrap-around is not allowed).</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg" alt="" /></p>
<pre><code class="hljs">Input: matrix = [[<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]
Output: <span class="hljs-number">4</span>
Explanation: The longest increasing path <span class="hljs-keyword">is</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>].
</code></pre>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg" alt="" /></p>
<pre><code class="hljs">Input: matrix = [[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]
Output: <span class="hljs-number">4</span>
Explanation: The longest increasing path <span class="hljs-keyword">is</span> [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]. Moving diagonally <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> allowed.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code class="hljs">Input: matrix = <span class="hljs-string">[[1]]</span>
Output: <span class="hljs-number">1</span>
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>m == matrix.length</code></p></li>
<li><p><code>n == matrix[i].length</code></p></li>
<li><p><code>1 &lt;= m, n &lt;= 200</code></p></li>
<li><p><code>0 &lt;= matrix[i][j] &lt;= 231 - 1</code></p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-javascript"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param <span class="hljs-type">{number[][]}</span> <span class="hljs-variable">matrix</span></span>
 * <span class="hljs-doctag">@return <span class="hljs-type">{number}</span></span>
 */</span>
<span class="hljs-keyword">var</span> longestIncreasingPath = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>{
    <span class="hljs-keyword">let</span> ylen = matrix.length, xlen = matrix[<span class="hljs-number">0</span>].length, ans = <span class="hljs-number">0</span>,
        memo = <span class="hljs-built_in">Array</span>.from({<span class="hljs-attr">length</span>: ylen}, el =&gt; <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(xlen))
    <span class="hljs-keyword">const</span> dfs = <span class="hljs-function">(<span class="hljs-params">y, x</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (memo[y][x]) <span class="hljs-keyword">return</span> memo[y][x]
        <span class="hljs-keyword">let</span> val = matrix[y][x]
        memo[y][x] = <span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.max(
            y &lt; ylen - <span class="hljs-number">1</span> &amp;&amp; matrix[y+<span class="hljs-number">1</span>][x] &lt; val ? dfs(y+<span class="hljs-number">1</span>,x) : <span class="hljs-number">0</span>,
            y &gt; <span class="hljs-number">0</span> &amp;&amp; matrix[y<span class="hljs-number">-1</span>][x] &lt; val ? dfs(y<span class="hljs-number">-1</span>,x) : <span class="hljs-number">0</span>,
            x &lt; xlen - <span class="hljs-number">1</span> &amp;&amp; matrix[y][x+<span class="hljs-number">1</span>] &lt; val ? dfs(y,x+<span class="hljs-number">1</span>) : <span class="hljs-number">0</span>,
            x &gt; <span class="hljs-number">0</span> &amp;&amp; matrix[y][x<span class="hljs-number">-1</span>] &lt; val ? dfs(y,x<span class="hljs-number">-1</span>) : <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> memo[y][x]
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; ylen; i++)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; xlen; j++)
            ans = <span class="hljs-built_in">Math</span>.max(ans, dfs(i, j))
    <span class="hljs-keyword">return</span> ans
};
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n * m * log(n * m)).</li>
<li>Space complexity : O(n * m * log(n * m)).</li>
</ul></article></main><footer><a href="https://github.com/BaffinLee/leetcode-javascript" target="_blank"><img src="https://baffinlee.com/leetcode-javascript/static/img/github.png" alt="github"/></a></footer></body></html>