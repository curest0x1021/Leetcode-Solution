<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Longest Common Subpath - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>1923. Longest Common Subpath</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/array">Array</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/binary-search">Binary Search</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/rolling-hash">Rolling Hash</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/suffix-array">Suffix Array</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/hash-function">Hash Function</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/reconstruct-itinerary.html">Reconstruct Itinerary</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/maximum-length-of-repeated-subarray.html">Maximum Length of Repeated Subarray</a></li></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>There is a country of <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code>. In this country, there is a road connecting <strong>every pair</strong> of cities.</p>
<p>There are <code>m</code> friends numbered from <code>0</code> to <code>m - 1</code> who are traveling through the country. Each one of them will take a path consisting of some cities. Each path is represented by an integer array that contains the visited cities in order. The path may contain a city <strong>more than once</strong>, but the same city will not be listed consecutively.</p>
<p>Given an integer <code>n</code> and a 2D integer array <code>paths</code> where <code>paths[i]</code> is an integer array representing the path of the <code>ith</code> friend, return **the length of the *<em>longest common subpath</em>* that is shared by <strong>every</strong> friend's path, or <strong><code>0</code></strong> if there is no common subpath at all**.</p>
<p>A <strong>subpath</strong> of a path is a contiguous sequence of cities within that path.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<pre><code class="hljs">Input: n = <span class="hljs-number">5</span>, paths = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],
                       [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],
                       [<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]
Output: <span class="hljs-number">2</span>
Explanation: The longest common subpath <span class="hljs-keyword">is</span> [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code class="hljs">Input: n = <span class="hljs-number">3</span>, paths = [[<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>]]
Output: <span class="hljs-number">0</span>
Explanation: There <span class="hljs-keyword">is</span> no common subpath <span class="hljs-keyword">shared</span> by the three paths.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code class="hljs">Input: n = <span class="hljs-number">5</span>, paths = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],
                       [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]
Output: <span class="hljs-number">1</span>
Explanation: The possible longest common subpaths are [<span class="hljs-number">0</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>], <span class="hljs-keyword">and</span> [<span class="hljs-number">4</span>]. All have a length of <span class="hljs-number">1.</span>
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>1 &lt;= n &lt;= 105</code></p></li>
<li><p><code>m == paths.length</code></p></li>
<li><p><code>2 &lt;= m &lt;= 105</code></p></li>
<li><p><code>sum(paths[i].length) &lt;= 105</code></p></li>
<li><p><code>0 &lt;= paths[i][j] &lt; n</code></p></li>
<li><p>The same city is not listed multiple times consecutively in <code>paths[i]</code>.</p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> BASE = <span class="hljs-number">100001</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> MOD = (<span class="hljs-keyword">long</span>) (Math.pow(<span class="hljs-number">10</span>, <span class="hljs-number">11</span>) + <span class="hljs-number">7</span>);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span>[] pow;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubpath</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] paths)</span> </span>{
        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] path : paths) {
            min = Math.min(min, path.length);
        }
        pow = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[min + <span class="hljs-number">1</span>];
        pow[<span class="hljs-number">0</span>]++;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= min; i++) {
            pow[i] = (pow[i - <span class="hljs-number">1</span>] * BASE) % MOD;
        }
        <span class="hljs-keyword">int</span> st = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> end = min;
        <span class="hljs-keyword">int</span> mid = (st + end) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">while</span> (st &lt;= end) {
            <span class="hljs-keyword">if</span> (commonSubstring(paths, mid)) {
                res = mid;
                st = mid + <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
                end = mid - <span class="hljs-number">1</span>;
            }
            mid = (st + end) / <span class="hljs-number">2</span>;
        }
        <span class="hljs-keyword">return</span> res;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">commonSubstring</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] paths, <span class="hljs-keyword">int</span> l)</span> </span>{
        HashSet&lt;Long&gt; set = rollingHash(paths[<span class="hljs-number">0</span>], l);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, n = paths.length; i &lt; n; i++) {
            set.retainAll(rollingHash(paths[i], l));
            <span class="hljs-keyword">if</span> (set.isEmpty()) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> HashSet&lt;Long&gt; <span class="hljs-title">rollingHash</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l)</span> </span>{
        HashSet&lt;Long&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
        <span class="hljs-keyword">long</span> hash = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) {
            hash = (hash * BASE + a[i]) % MOD;
        }
        set.add(hash);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = a.length, curr = l, prev = <span class="hljs-number">0</span>; curr &lt; n; prev++, curr++) {
            hash = (((hash * BASE) % MOD - (a[prev] * pow[l]) % MOD + a[curr]) + MOD) % MOD;
            set.add(hash);
        }
        <span class="hljs-keyword">return</span> set;
    }
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>