<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Merge BSTs to Create Single BST - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>1932. Merge BSTs to Create Single BST</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/hash-table">Hash Table</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/binary-search">Binary Search</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/tree">Tree</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/depth-first-search">Depth-First Search</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/binary-tree">Binary Tree</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>You are given <code>n</code> <strong>BST (binary search tree) root nodes</strong> for <code>n</code> separate BSTs stored in an array <code>trees</code> (<strong>0-indexed</strong>). Each BST in <code>trees</code> has <strong>at most 3 nodes</strong>, and no two roots have the same value. In one operation, you can:</p>
<ul>
<li><p>Select two <strong>distinct</strong> indices <code>i</code> and <code>j</code> such that the value stored at one of the **leaves **of <code>trees[i]</code> is equal to the <strong>root value</strong> of <code>trees[j]</code>.</p></li>
<li><p>Replace the leaf node in <code>trees[i]</code> with <code>trees[j]</code>.</p></li>
<li><p>Remove <code>trees[j]</code> from <code>trees</code>.</p></li>
</ul>
<p>Return** the <strong>root</strong> of the resulting BST if it is possible to form a valid BST after performing <strong><code>n - 1</code></strong> operations, or**** **<code>null</code> *if it is impossible to create a valid BST*.</p>
<p>A BST (binary search tree) is a binary tree where each node satisfies the following property:</p>
<ul>
<li><p>Every node in the node's left subtree has a value&nbsp;<strong>strictly less</strong>&nbsp;than the node's value.</p></li>
<li><p>Every node in the node's right subtree has a value&nbsp;<strong>strictly greater</strong>&nbsp;than the node's value.</p></li>
</ul>
<p>A leaf is a node that has no children.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/08/d1.png" alt="" /></p>
<pre><code class="hljs">Input: trees = [[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>]]
Output: [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>]
Explanation:
In the first operation, pick i=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> j=<span class="hljs-number">0</span>, <span class="hljs-keyword">and</span> merge trees[<span class="hljs-number">0</span>] <span class="hljs-built_in">int</span>o trees[<span class="hljs-number">1</span>].
Delete trees[<span class="hljs-number">0</span>], so trees = [[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>]].

In the second operation, pick i=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j=<span class="hljs-number">1</span>, <span class="hljs-keyword">and</span> merge trees[<span class="hljs-number">1</span>] <span class="hljs-built_in">int</span>o trees[<span class="hljs-number">0</span>].
Delete trees[<span class="hljs-number">1</span>], so trees = [[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>]].

The resulting tree, shown above, <span class="hljs-keyword">is</span> a valid BST, so <span class="hljs-keyword">return</span> its root.
</code></pre>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/08/d2.png" alt="" /></p>
<pre><code class="hljs">Input: trees = [[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]
Output: []
Explanation:
Pick i=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> merge trees[<span class="hljs-number">1</span>] <span class="hljs-built_in">int</span>o trees[<span class="hljs-number">0</span>].
Delete trees[<span class="hljs-number">1</span>], so trees = [[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]].

The resulting tree <span class="hljs-keyword">is</span> shown above. This <span class="hljs-keyword">is</span> the only valid operation that can be performed, but the resulting tree <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a valid BST, so <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>.
</code></pre>
<p><strong>Example 3:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/08/d3.png" alt="" /></p>
<pre><code class="hljs"><span class="hljs-keyword">Input</span>: trees = [[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">3</span>]]
Output: []
Explanation: It <span class="hljs-keyword">is</span> impossible <span class="hljs-keyword">to</span> <span class="hljs-keyword">perform</span> <span class="hljs-keyword">any</span> operations.
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>n == trees.length</code></p></li>
<li><p><code>1 &lt;= n &lt;= 5 * 104</code></p></li>
<li><p>The number of nodes in each tree is in the range <code>[1, 3]</code>.</p></li>
<li><p>Each node in the input may have children but no grandchildren.</p></li>
<li><p>No two roots of <code>trees</code> have the same value.</p></li>
<li><p>All the trees in the input are <strong>valid BSTs</strong>.</p></li>
<li><p><code>1 &lt;= TreeNode.val &lt;= 5 * 104</code>.</p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-java"><span class="hljs-keyword">import</span> java.util.ArrayDeque;
<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.Queue;
<span class="hljs-comment">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">canMerge</span><span class="hljs-params">(List&lt;TreeNode&gt; trees)</span> </span>{
        Map&lt;Integer, TreeNode&gt; valRootMap = <span class="hljs-keyword">new</span> HashMap&lt;Integer, TreeNode&gt;();
        Map&lt;TreeNode, <span class="hljs-keyword">int</span>[]&gt; minMaxMap = <span class="hljs-keyword">new</span> HashMap&lt;TreeNode, <span class="hljs-keyword">int</span>[]&gt;();
        Map&lt;TreeNode, <span class="hljs-keyword">int</span>[]&gt; legalRangeMap = <span class="hljs-keyword">new</span> HashMap&lt;TreeNode, <span class="hljs-keyword">int</span>[]&gt;();
        <span class="hljs-keyword">for</span> (TreeNode root : trees) {
            valRootMap.put(root.val, root);
            getMinMax(minMaxMap, root);
            getLegalRange(legalRangeMap, root, Integer.MIN_VALUE, Integer.MAX_VALUE);
        }
        Map&lt;Integer, Integer&gt; leavesCountMap = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();
        <span class="hljs-keyword">for</span> (TreeNode tree : trees)
            visitLeaves(leavesCountMap, tree, <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : leavesCountMap.entrySet()) {
            <span class="hljs-keyword">if</span> (entry.getValue() &gt; <span class="hljs-number">1</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
        Set&lt;TreeNode&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;TreeNode&gt;(trees);
        <span class="hljs-keyword">for</span> (TreeNode root : trees) {
            <span class="hljs-keyword">if</span> (isLeaf(root))
                <span class="hljs-keyword">continue</span>;
            TreeNode parent = getLeafParent(root);
            TreeNode left = parent.left, right = parent.right;
            <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span> &amp;&amp; valRootMap.containsKey(left.val)) {
                <span class="hljs-keyword">int</span>[] legalRange = legalRangeMap.get(left);
                TreeNode prevRoot = valRootMap.get(left.val);
                <span class="hljs-keyword">int</span>[] minMax = minMaxMap.get(prevRoot);
                <span class="hljs-keyword">if</span> (minMax[<span class="hljs-number">0</span>] &lt; legalRange[<span class="hljs-number">0</span>] || minMax[<span class="hljs-number">1</span>] &gt; legalRange[<span class="hljs-number">1</span>])
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
                parent.left = prevRoot;
                legalRangeMap.put(prevRoot, legalRange);
                <span class="hljs-keyword">int</span>[] parentMinMax = minMaxMap.get(parent);
                <span class="hljs-keyword">int</span>[] newMinMax = {minMax[<span class="hljs-number">0</span>], parentMinMax[<span class="hljs-number">1</span>]};
                minMaxMap.put(prevRoot, newMinMax);
                set.remove(prevRoot);
            }
            <span class="hljs-keyword">if</span> (right != <span class="hljs-keyword">null</span> &amp;&amp; valRootMap.containsKey(right.val)) {
                <span class="hljs-keyword">int</span>[] legalRange = legalRangeMap.get(right);
                TreeNode prevRoot = valRootMap.get(right.val);
                <span class="hljs-keyword">int</span>[] minMax = minMaxMap.get(prevRoot);
                <span class="hljs-keyword">if</span> (minMax[<span class="hljs-number">0</span>] &lt; legalRange[<span class="hljs-number">0</span>] || minMax[<span class="hljs-number">1</span>] &gt; legalRange[<span class="hljs-number">1</span>])
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
                parent.right = prevRoot;
                legalRangeMap.put(prevRoot, legalRange);
                <span class="hljs-keyword">int</span>[] parentMinMax = minMaxMap.get(parent);
                <span class="hljs-keyword">int</span>[] newMinMax = {parentMinMax[<span class="hljs-number">0</span>], minMax[<span class="hljs-number">1</span>]};
                minMaxMap.put(prevRoot, newMinMax);
                set.remove(prevRoot);
            }
        }
        <span class="hljs-keyword">if</span> (set.size() != <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        List&lt;TreeNode&gt; remain = <span class="hljs-keyword">new</span> ArrayList&lt;TreeNode&gt;(set);
        TreeNode root = remain.get(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (isValidBST(root))
            <span class="hljs-keyword">return</span> root;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getMinMax</span><span class="hljs-params">(Map&lt;TreeNode, <span class="hljs-keyword">int</span>[]&gt; minMaxMap, TreeNode root)</span> </span>{
        TreeNode minNode = root, maxNode = root;
        <span class="hljs-keyword">while</span> (minNode.left != <span class="hljs-keyword">null</span>)
            minNode = minNode.left;
        <span class="hljs-keyword">while</span> (maxNode.right != <span class="hljs-keyword">null</span>)
            maxNode = maxNode.right;
        minMaxMap.put(root, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{minNode.val, maxNode.val});
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLegalRange</span><span class="hljs-params">(Map&lt;TreeNode, <span class="hljs-keyword">int</span>[]&gt; legalRangeMap, TreeNode node, <span class="hljs-keyword">int</span> min, <span class="hljs-keyword">int</span> max)</span> </span>{
        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">return</span>;
        legalRangeMap.put(node, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{min, max});
        getLegalRange(legalRangeMap, node.left, min, node.val - <span class="hljs-number">1</span>);
        getLegalRange(legalRangeMap, node.right, node.val + <span class="hljs-number">1</span>, max);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitLeaves</span><span class="hljs-params">(Map&lt;Integer, Integer&gt; leavesCountMap, TreeNode node, <span class="hljs-keyword">boolean</span> isRoot)</span> </span>{
        <span class="hljs-keyword">if</span> (isLeaf(node)) {
            <span class="hljs-keyword">if</span> (!isRoot)
                leavesCountMap.put(node.val, leavesCountMap.getOrDefault(node.val, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)
                visitLeaves(leavesCountMap, node.left, <span class="hljs-keyword">false</span>);
            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)
                visitLeaves(leavesCountMap, node.right, <span class="hljs-keyword">false</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLeaf</span><span class="hljs-params">(TreeNode node)</span> </span>{
        <span class="hljs-keyword">return</span> node != <span class="hljs-keyword">null</span> &amp;&amp; node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">getLeafParent</span><span class="hljs-params">(TreeNode root)</span> </span>{
        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span> &amp;&amp; root.right != <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">return</span> root;
        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">if</span> (isLeaf(root.left))
                <span class="hljs-keyword">return</span> root;
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> root.left;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (isLeaf(root.right))
                <span class="hljs-keyword">return</span> root;
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> root.right;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>{
        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        TreeNode prev = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;
        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();
        TreeNode node = root;
        <span class="hljs-keyword">while</span> (!stack.isEmpty() || node != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) {
                stack.push(node);
                node = node.left;
            }
            TreeNode curr = stack.pop();
            <span class="hljs-keyword">if</span> (prev != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">if</span> (prev.val &gt;= curr.val)
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }
            prev = curr;
            node = curr.right;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>