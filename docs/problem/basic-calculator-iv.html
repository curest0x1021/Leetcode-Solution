<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Basic Calculator IV - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://baffinlee.com/leetcode-javascript/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://baffinlee.com/leetcode-javascript/static/css/app.css"/></head><body><header><h1>770. Basic Calculator IV</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://baffinlee.com/leetcode-javascript/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://baffinlee.com/leetcode-javascript/tag/hash-table">Hash Table</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/math">Math</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/string">String</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/stack">Stack</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/recursion">Recursion</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"><li><a href="https://baffinlee.com/leetcode-javascript/problem/parse-lisp-expression.html">Parse Lisp Expression</a></li><li><a href="https://baffinlee.com/leetcode-javascript/problem/basic-calculator-iii.html">Basic Calculator III</a></li></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>Given an expression such as <code>expression = "e + 8 - a + 5"</code> and an evaluation map such as <code>{"e": 1}</code> (given in terms of <code>evalvars = ["e"]</code> and <code>evalints = [1]</code>), return a list of tokens representing the simplified expression, such as <code>["-1*a","14"]</code></p>
<ul>
<li><p>An expression alternates chunks and symbols, with a space separating each chunk and symbol.</p></li>
<li><p>A chunk is either an expression in parentheses, a variable, or a non-negative integer.</p></li>
<li><p>A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like <code>"2x"</code> or <code>"-x"</code>.</p></li>
</ul>
<p>Expressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction.</p>
<ul>
<li>For example, <code>expression = "1 + 2 * 3"</code> has an answer of <code>["7"]</code>.</li>
</ul>
<p>The format of the output is as follows:</p>
<pre><code>For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically.
</code></pre>
<ul>
<li><p>For example, we would never write a term like <code>"b*a*c"</code>, only <code>"a*b*c"</code>.</p>
<p>Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.</p></li>
<li><p>For example, <code>"a*a*b*c"</code> has degree <code>4</code>.</p></li>

<li><p>The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.</p></li>
<li><p>An example of a well-formatted answer is <code>["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"]</code>.
Terms (including constant terms) with coefficient <code>0</code> are not included.</p></li>
<li><p>For example, an expression of <code>"0"</code> has an output of <code>[]</code>.</p></li>
</ul>
<p><strong>Note:</strong> You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-231, 231 - 1]</code>.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<pre><code class="hljs">Input: <span class="hljs-attr">expression</span> = <span class="hljs-string">"e + 8 - a + 5"</span>, <span class="hljs-attr">evalvars</span> = [<span class="hljs-string">"e"</span>], <span class="hljs-attr">evalints</span> = [<span class="hljs-number">1</span>]
Output: [<span class="hljs-string">"-1*a"</span>,<span class="hljs-string">"14"</span>]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code class="hljs">Input: <span class="hljs-attr">expression</span> = <span class="hljs-string">"e - 8 + temperature - pressure"</span>, <span class="hljs-attr">evalvars</span> = [<span class="hljs-string">"e"</span>, <span class="hljs-string">"temperature"</span>], <span class="hljs-attr">evalints</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">12</span>]
Output: [<span class="hljs-string">"-1*pressure"</span>,<span class="hljs-string">"5"</span>]
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code class="hljs">Input: <span class="hljs-attr">expression</span> = <span class="hljs-string">"(e + 8) * (e - 8)"</span>, <span class="hljs-attr">evalvars</span> = [], <span class="hljs-attr">evalints</span> = []
Output: [<span class="hljs-string">"1*e*e"</span>,<span class="hljs-string">"-64"</span>]
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>1 &lt;= expression.length &lt;= 250</code></p></li>
<li><p><code>expression</code> consists of lowercase English letters, digits, <code>'+'</code>, <code>'-'</code>, <code>'*'</code>, <code>'('</code>, <code>')'</code>, <code>' '</code>.</p></li>
<li><p><code>expression</code> does not contain any leading or trailing spaces.</p></li>
<li><p>All the tokens in <code>expression</code> are separated by a single space.</p></li>
<li><p><code>0 &lt;= evalvars.length &lt;= 100</code></p></li>
<li><p><code>1 &lt;= evalvars[i].length &lt;= 20</code></p></li>
<li><p><code>evalvars[i]</code> consists of lowercase English letters.</p></li>
<li><p><code>evalints.length == evalvars.length</code></p></li>
<li><p><code>-100 &lt;= evalints[i] &lt;= 100</code></p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-javascript"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param <span class="hljs-type">{string}</span> <span class="hljs-variable">expression</span></span>
 * <span class="hljs-doctag">@param <span class="hljs-type">{string[]}</span> <span class="hljs-variable">evalvars</span></span>
 * <span class="hljs-doctag">@param <span class="hljs-type">{number[]}</span> <span class="hljs-variable">evalints</span></span>
 * <span class="hljs-doctag">@return <span class="hljs-type">{string[]}</span></span>
 */</span>
<span class="hljs-keyword">const</span> basicCalculatorIV = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">expression, evalvars, evalints</span>) </span>{
  <span class="hljs-keyword">const</span> record = {}; <span class="hljs-comment">// { variable: value, ... }</span>
  evalvars.forEach(<span class="hljs-function">(<span class="hljs-params">k, i</span>) =&gt;</span> record[k] = evalints[i]);
  <span class="hljs-keyword">const</span> expr = calculator(expression); <span class="hljs-comment">// expr: { expr: coeff, ... }</span>
  <span class="hljs-keyword">const</span> terms = collectTerms(expr);
  <span class="hljs-keyword">const</span> ans = buildOutput(expr, terms);
  <span class="hljs-keyword">return</span> ans;

  <span class="hljs-comment">// calculator will return the final expr like: { e*e: 1, #: 64 }</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculator</span>(<span class="hljs-params">expression</span>) </span>{
    <span class="hljs-keyword">if</span> (!expression.length) <span class="hljs-keyword">return</span> {};

    expression += <span class="hljs-string">" +"</span>; <span class="hljs-comment">// this is to trigger adding `cur` to `result`,</span>
                        <span class="hljs-comment">// otherwise, it might stop when finish calculating `cur`.</span>
    <span class="hljs-keyword">const</span> n = expression.length;
    <span class="hljs-keyword">let</span> result = {}, cur = {};
    <span class="hljs-keyword">let</span> operator = <span class="hljs-string">"+"</span>, i;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>) { <span class="hljs-comment">// i += 2 because there's a space between each expression</span>
      <span class="hljs-keyword">const</span> expr = getExpr();    <span class="hljs-comment">// recursively to get the nested expr</span>
      <span class="hljs-comment">// first try an expression with no parentheses and log the expr</span>
      <span class="hljs-comment">// then try an expression with parentheses and log the expr</span>
      <span class="hljs-comment">// You'll probably get a feel how the recursion works</span>
      <span class="hljs-keyword">if</span> ([<span class="hljs-string">"+"</span>, <span class="hljs-string">"-"</span>, <span class="hljs-string">"*"</span>].includes(expression[i]) || i == n - <span class="hljs-number">1</span>) {
        <span class="hljs-comment">// update cur based on operators,</span>
        <span class="hljs-comment">// for example for expression "e + 8", cur will have values: { e: 1 } and { #: 8 } </span>
        <span class="hljs-comment">// result will have values: { e: 1 } and then { e: 1, #: 8 }.</span>
        <span class="hljs-keyword">if</span> (operator == <span class="hljs-string">"+"</span>) cur = add(cur, expr);
        <span class="hljs-keyword">if</span> (operator == <span class="hljs-string">"-"</span>) cur = sub(cur, expr);
        <span class="hljs-keyword">if</span> (operator == <span class="hljs-string">"*"</span>) cur = mul(cur, expr);
        <span class="hljs-comment">// if meet '+' or '-', we add cur to result.</span>
        <span class="hljs-comment">// also this is why we added the " +" to expression</span>
        <span class="hljs-comment">// because otherwise, for example when the expression is "a * b * c", then </span>
        <span class="hljs-comment">// cur will have values: { a: 1 }, { a*b: 1 }, and { a*b*c: 1 }.</span>
        <span class="hljs-comment">// but result will not get populated.</span>
        <span class="hljs-keyword">if</span> ([<span class="hljs-string">"+"</span>, <span class="hljs-string">"-"</span>].includes(expression[i]) || i == n - <span class="hljs-number">1</span>) {
          result = add(result, cur);
          cur = {};
        }
        operator = expression[i];
      }
    }
    <span class="hljs-keyword">return</span> result;

    <span class="hljs-comment">// calculator will return an expr like: { a: 1} for non-nested problem, </span>
    <span class="hljs-comment">// and { a: 1, b: 1, #: 8 } for a nested problem</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getExpr</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (i &gt;= n) <span class="hljs-keyword">return</span> result;

      <span class="hljs-keyword">let</span> expr = {}, start = i;
      <span class="hljs-keyword">if</span> (expression[i] == <span class="hljs-string">"("</span>) { <span class="hljs-comment">// found a subproblem</span>
        <span class="hljs-keyword">const</span> stk = [];
        stk.push(i);
        i += <span class="hljs-number">1</span>;
        <span class="hljs-comment">// find boundaries of the subproblem, </span>
        <span class="hljs-comment">// if reaches the end of expression or parentheses pair closed</span>
        <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; stk.length) {
          <span class="hljs-keyword">if</span> (expression[i] == <span class="hljs-string">"("</span>) stk.push(i);
          <span class="hljs-keyword">if</span> (expression[i] == <span class="hljs-string">")"</span>) stk.pop();
          i += <span class="hljs-number">1</span>;
        }
        <span class="hljs-comment">// the subproblem could look like this first: ((a - b) * (b - c) + (c - a))</span>
        <span class="hljs-comment">// then look like: a - b =&gt; { a: 1, b: 1 }</span>
        <span class="hljs-comment">// then look like: b - c =&gt; { b: 1, c: -1 }</span>
        <span class="hljs-comment">// then look like: c - a =&gt; { c: 1, a: -1 }</span>
        <span class="hljs-keyword">const</span> sub = expression.slice(start + <span class="hljs-number">1</span>, i<span class="hljs-number">-1</span>);
        <span class="hljs-comment">// for each of the subproblems above, calculator knows how to caculate it on its own,</span>
        <span class="hljs-comment">// it won't reach this part again, because the subproblem does not have '(' anymore.</span>
        expr = calculator(sub);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isdigit(expression[i])) { <span class="hljs-comment">// collect digits expr, like { #: 84 }</span>
        <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; isdigit(expression[i])) i += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">const</span> val = expression.slice(start, i);
        expr[<span class="hljs-string">"#"</span>] = +val;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// collect expression key, like { a: 1 },</span>
        <span class="hljs-comment">// also it could be a pre-defined variable, so it becomes a constant</span>
        <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; expression[i] != <span class="hljs-string">" "</span>) i += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">const</span> key = expression.slice(start, i);
        <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> record) { <span class="hljs-comment">// found variable constant</span>
          expr[<span class="hljs-string">"#"</span>] = record[key];
        } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// found a expression key</span>
          expr[key] = <span class="hljs-number">1</span>;
        }
      }
      i += <span class="hljs-number">1</span>;
      <span class="hljs-keyword">return</span> expr;
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collectTerms</span>(<span class="hljs-params">tree</span>) </span>{
    <span class="hljs-keyword">const</span> terms = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, val] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(tree)) {
      <span class="hljs-keyword">if</span> (val &amp;&amp; key != <span class="hljs-string">"#"</span>) {
        <span class="hljs-comment">// order depends on how many '*' the key has</span>
        <span class="hljs-keyword">const</span> order = key.split(<span class="hljs-string">""</span>).filter(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c == <span class="hljs-string">"*"</span>).length;
        terms.push([key, order]);
      }
    }
    <span class="hljs-comment">// sort by order desc and key asc</span>
    terms.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">1</span>] != b[<span class="hljs-number">1</span>] ? b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>] : a[<span class="hljs-number">0</span>].localeCompare(b[<span class="hljs-number">0</span>]))
    <span class="hljs-keyword">return</span> terms.map(<span class="hljs-function">(<span class="hljs-params">[key]</span>) =&gt;</span> key);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildOutput</span>(<span class="hljs-params">tree, terms</span>) </span>{
    <span class="hljs-keyword">const</span> ans = terms.map(<span class="hljs-function"><span class="hljs-params">term</span> =&gt;</span> tree[term] + <span class="hljs-string">"*"</span> + term);
    <span class="hljs-keyword">const</span> constant = tree[<span class="hljs-string">"#"</span>];
    <span class="hljs-keyword">if</span> (constant) ans.push(constant.toString());
    <span class="hljs-keyword">return</span> ans;
  }
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isdigit</span>(<span class="hljs-params">char</span>) </span>{
  <span class="hljs-keyword">return</span> char &gt;= <span class="hljs-string">"0"</span> &amp;&amp; char &lt;= <span class="hljs-string">"9"</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combineKey</span>(<span class="hljs-params">s1, s2</span>) </span>{
  <span class="hljs-keyword">return</span> s1.split(<span class="hljs-string">"*"</span>).concat(s2.split(<span class="hljs-string">"*"</span>)).sort().join(<span class="hljs-string">"*"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-built_in">Object</span>.entries(b).forEach(<span class="hljs-function">(<span class="hljs-params">[k, v]</span>) =&gt;</span> a[k] = (a[k] || <span class="hljs-number">0</span>) + v);
  <span class="hljs-keyword">return</span> a;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sub</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-built_in">Object</span>.entries(b).forEach(<span class="hljs-function">(<span class="hljs-params">[k, v]</span>) =&gt;</span> a[k] = (a[k] || <span class="hljs-number">0</span>) - v);
  <span class="hljs-keyword">return</span> a;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mul</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">const</span> ans = {};
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [ak, av] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(a)) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [bk, bv] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(b)) { 
      <span class="hljs-keyword">if</span> (ak == <span class="hljs-string">"#"</span>) {
        ans[bk] = (ans[bk] || <span class="hljs-number">0</span>) + av * bv;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bk == <span class="hljs-string">"#"</span>) {
        ans[ak] = (ans[ak] || <span class="hljs-number">0</span>) + av * bv;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">const</span> key = combineKey(ak, bk);
        ans[key] = (ans[key] || <span class="hljs-number">0</span>) + av * bv;
      }
    }
  }
  <span class="hljs-keyword">return</span> ans;
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/BaffinLee/leetcode-javascript" target="_blank"><img src="https://baffinlee.com/leetcode-javascript/static/img/github.png" alt="github"/></a></footer></body></html>