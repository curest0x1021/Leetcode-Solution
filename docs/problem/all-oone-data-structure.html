<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>All O`one Data Structure - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://baffinlee.com/leetcode-javascript/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://baffinlee.com/leetcode-javascript/static/css/app.css"/></head><body><header><h1>432. All O`one Data Structure</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://baffinlee.com/leetcode-javascript/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://baffinlee.com/leetcode-javascript/tag/hash-table">Hash Table</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/linked-list">Linked List</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/design">Design</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/doubly-linked-list">Doubly-Linked List</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.</p>
<p>Implement the <code>AllOne</code> class:</p>
<ul>
<li><p><code>AllOne()</code> Initializes the object of the data structure.</p></li>
<li><p><code>inc(String key)</code> Increments the count of the string <code>key</code> by <code>1</code>. If <code>key</code> does not exist in the data structure, insert it with count <code>1</code>.</p></li>
<li><p><code>dec(String key)</code> Decrements the count of the string <code>key</code> by <code>1</code>. If the count of <code>key</code> is <code>0</code> after the decrement, remove it from the data structure. It is guaranteed that <code>key</code> exists in the data structure before the decrement.</p></li>
<li><p><code>getMaxKey()</code> Returns one of the keys with the maximal count. If no element exists, return an empty string <code>""</code>.</p></li>
<li><p><code>getMinKey()</code> Returns one of the keys with the minimum count. If no element exists, return an empty string <code>""</code>.</p></li>
</ul>
<p><strong>Note</strong> that each function must run in <code>O(1)</code> average time complexity.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<pre><code class="hljs"><span class="hljs-symbol">Input</span>
[<span class="hljs-string">"AllOne"</span>, <span class="hljs-string">"inc"</span>, <span class="hljs-string">"inc"</span>, <span class="hljs-string">"getMaxKey"</span>, <span class="hljs-string">"getMinKey"</span>, <span class="hljs-string">"inc"</span>, <span class="hljs-string">"getMaxKey"</span>, <span class="hljs-string">"getMinKey"</span>]
[[], [<span class="hljs-string">"hello"</span>], [<span class="hljs-string">"hello"</span>], [], [], [<span class="hljs-string">"leet"</span>], [], []]
<span class="hljs-symbol">Output</span>
[null, null, null, <span class="hljs-string">"hello"</span>, <span class="hljs-string">"hello"</span>, null, <span class="hljs-string">"hello"</span>, <span class="hljs-string">"leet"</span>]

<span class="hljs-symbol">Explanation</span>
<span class="hljs-symbol">AllOne</span> allOne = new <span class="hljs-symbol">AllOne</span>();
allOne.inc(<span class="hljs-string">"hello"</span>);
allOne.inc(<span class="hljs-string">"hello"</span>);
allOne.getMaxKey(); // return <span class="hljs-string">"hello"</span>
allOne.getMinKey(); // return <span class="hljs-string">"hello"</span>
allOne.inc(<span class="hljs-string">"leet"</span>);
allOne.getMaxKey(); // return <span class="hljs-string">"hello"</span>
allOne.getMinKey(); // return <span class="hljs-string">"leet"</span>
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>1 &lt;= key.length &lt;= 10</code></p></li>
<li><p><code>key</code> consists of lowercase English letters.</p></li>
<li><p>It is guaranteed that for each call to <code>dec</code>, <code>key</code> is existing in the data structure.</p></li>
<li><p>At most <code>5 * 104</code>&nbsp;calls will be made to <code>inc</code>, <code>dec</code>, <code>getMaxKey</code>, and <code>getMinKey</code>.</p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllOne</span> </span>{
    <span class="hljs-comment">// maintain a doubly linked list of Buckets</span>
    <span class="hljs-keyword">private</span> Bucket head;
    <span class="hljs-keyword">private</span> Bucket tail;
    <span class="hljs-comment">// for accessing a specific Bucket among the Bucket list in O(1) time</span>
    <span class="hljs-keyword">private</span> Map&lt;Integer, Bucket&gt; countBucketMap;
    <span class="hljs-comment">// keep track of count of keys</span>
    <span class="hljs-keyword">private</span> Map&lt;String, Integer&gt; keyCountMap;

    <span class="hljs-comment">// each Bucket contains all the keys with the same count</span>
    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bucket</span> </span>{
        <span class="hljs-keyword">int</span> count;
        Set&lt;String&gt; keySet;
        Bucket next;
        Bucket pre;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bucket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cnt)</span> </span>{
            count = cnt;
            keySet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
        }
    }

    <span class="hljs-comment">/** Initialize your data structure here. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AllOne</span><span class="hljs-params">()</span> </span>{
        head = <span class="hljs-keyword">new</span> Bucket(Integer.MIN_VALUE);
        tail = <span class="hljs-keyword">new</span> Bucket(Integer.MAX_VALUE);
        head.next = tail;
        tail.pre = head;
        countBucketMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        keyCountMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    }

    <span class="hljs-comment">/** Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(String key)</span> </span>{
        <span class="hljs-keyword">if</span> (keyCountMap.containsKey(key)) {
            changeKey(key, <span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> {
            keyCountMap.put(key, <span class="hljs-number">1</span>);
            <span class="hljs-keyword">if</span> (head.next.count != <span class="hljs-number">1</span>) 
                addBucketAfter(<span class="hljs-keyword">new</span> Bucket(<span class="hljs-number">1</span>), head);
            head.next.keySet.add(key);
            countBucketMap.put(<span class="hljs-number">1</span>, head.next);
        }
    }

    <span class="hljs-comment">/** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">(String key)</span> </span>{
        <span class="hljs-keyword">if</span> (keyCountMap.containsKey(key)) {
            <span class="hljs-keyword">int</span> count = keyCountMap.get(key);
            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) {
                keyCountMap.remove(key);
                removeKeyFromBucket(countBucketMap.get(count), key);
            } <span class="hljs-keyword">else</span> {
                changeKey(key, -<span class="hljs-number">1</span>);
            }
        }
    }

    <span class="hljs-comment">/** Returns one of the keys with maximal value. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMaxKey</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> tail.pre == head ? <span class="hljs-string">""</span> : (String) tail.pre.keySet.iterator().next();
    }

    <span class="hljs-comment">/** Returns one of the keys with Minimal value. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMinKey</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> head.next == tail ? <span class="hljs-string">""</span> : (String) head.next.keySet.iterator().next();        
    }

    <span class="hljs-comment">// helper function to make change on given key according to offset</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeKey</span><span class="hljs-params">(String key, <span class="hljs-keyword">int</span> offset)</span> </span>{
        <span class="hljs-keyword">int</span> count = keyCountMap.get(key);
        keyCountMap.put(key, count + offset);
        Bucket curBucket = countBucketMap.get(count);
        Bucket newBucket;
        <span class="hljs-keyword">if</span> (countBucketMap.containsKey(count + offset)) {
            <span class="hljs-comment">// target Bucket already exists</span>
            newBucket = countBucketMap.get(count + offset);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// add new Bucket</span>
            newBucket = <span class="hljs-keyword">new</span> Bucket(count + offset);
            countBucketMap.put(count + offset, newBucket);
            addBucketAfter(newBucket, offset == <span class="hljs-number">1</span> ? curBucket : curBucket.pre);
        }
        newBucket.keySet.add(key);
        removeKeyFromBucket(curBucket, key);
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeKeyFromBucket</span><span class="hljs-params">(Bucket bucket, String key)</span> </span>{
        bucket.keySet.remove(key);
        <span class="hljs-keyword">if</span> (bucket.keySet.size() == <span class="hljs-number">0</span>) {
            removeBucketFromList(bucket);
            countBucketMap.remove(bucket.count);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeBucketFromList</span><span class="hljs-params">(Bucket bucket)</span> </span>{
        bucket.pre.next = bucket.next;
        bucket.next.pre = bucket.pre;
        bucket.next = <span class="hljs-keyword">null</span>;
        bucket.pre = <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-comment">// add newBucket after preBucket</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBucketAfter</span><span class="hljs-params">(Bucket newBucket, Bucket preBucket)</span> </span>{
        newBucket.pre = preBucket;
        newBucket.next = preBucket.next;
        preBucket.next.pre = newBucket;
        preBucket.next = newBucket;
    }
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/BaffinLee/leetcode-javascript" target="_blank"><img src="https://baffinlee.com/leetcode-javascript/static/img/github.png" alt="github"/></a></footer></body></html>