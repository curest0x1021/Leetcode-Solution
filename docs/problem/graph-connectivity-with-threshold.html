<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Graph Connectivity With Threshold - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>1627. Graph Connectivity With Threshold</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/array">Array</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/math">Math</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/union-find">Union Find</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>We have <code>n</code> cities labeled from <code>1</code> to <code>n</code>. Two different cities with labels <code>x</code> and <code>y</code> are directly connected by a bidirectional road if and only if <code>x</code> and <code>y</code> share a common divisor <strong>strictly greater</strong> than some <code>threshold</code>. More formally, cities with labels <code>x</code> and <code>y</code> have a road between them if there exists an integer <code>z</code> such that all of the following are true:</p>
<ul>
<li><p><code>x % z == 0</code>,</p></li>
<li><p><code>y % z == 0</code>, and</p></li>
<li><p><code>z &gt; threshold</code>.</p></li>
</ul>
<p>Given the two integers, <code>n</code> and <code>threshold</code>, and an array of <code>queries</code>, you must determine for each <code>queries[i] = [ai, bi]</code> if cities <code>ai</code> and <code>bi</code> are connected directly or indirectly.&nbsp;(i.e. there is some path between them).</p>
<p>Return **an array *<em><code>answer</code></em>*, where *<em><code>answer.length == queries.length</code></em>* and <strong><code>answer[i]</code></strong> is <strong><code>true</code></strong> if for the <strong><code>ith</code></strong> query, there is a path between <strong><code>ai</code></strong> and <strong><code>bi</code></strong>, or <strong><code>answer[i]</code></strong> is <strong><code>false</code></strong> if there is no path.**</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/09/ex1.jpg" alt="" /></p>
<pre><code class="hljs">Input: n = <span class="hljs-number">6</span>, threshold = <span class="hljs-number">2</span>, queries = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]]
Output: [<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">true</span>]
Explanation: The divisors <span class="hljs-keyword">for</span> each number:
<span class="hljs-number">1</span>:   <span class="hljs-number">1</span>
<span class="hljs-number">2</span>:   <span class="hljs-number">1</span>, <span class="hljs-number">2</span>
<span class="hljs-number">3</span>:   <span class="hljs-number">1</span>, <span class="hljs-number">3</span>
<span class="hljs-number">4</span>:   <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>
<span class="hljs-number">5</span>:   <span class="hljs-number">1</span>, <span class="hljs-number">5</span>
<span class="hljs-number">6</span>:   <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>
Using the underlined divisors above the threshold, only cities <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">6</span> share a common divisor, so they are the
only ones directly connected. The result of each query:
[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]   <span class="hljs-number">1</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> connected to <span class="hljs-number">4</span>
[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]   <span class="hljs-number">2</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> connected to <span class="hljs-number">5</span>
[<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]   <span class="hljs-number">3</span> <span class="hljs-keyword">is</span> connected to <span class="hljs-number">6</span> through path <span class="hljs-number">3</span>-<span class="hljs-number">-6</span>
</code></pre>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/10/tmp.jpg" alt="" /></p>
<pre><code class="hljs">Input: n = <span class="hljs-number">6</span>, threshold = <span class="hljs-number">0</span>, queries = [[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]]
Output: [<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>]
Explanation: The divisors <span class="hljs-keyword">for</span> each number are the same as the previous example. However, since the threshold <span class="hljs-keyword">is</span> <span class="hljs-number">0</span>,
all divisors can be used. Since all numbers share <span class="hljs-number">1</span> as a divisor, all cities are connected.
</code></pre>
<p><strong>Example 3:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/17/ex3.jpg" alt="" /></p>
<pre><code class="hljs">Input: n = <span class="hljs-number">5</span>, threshold = <span class="hljs-number">1</span>, queries = [[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]
Output: [<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>]
Explanation: Only cities <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-number">4</span> share a common divisor <span class="hljs-number">2</span> which <span class="hljs-keyword">is</span> strictly greater than the threshold <span class="hljs-number">1</span>, so they are the only ones directly connected.
Please notice that there can be multiple queries <span class="hljs-keyword">for</span> the same pair of nodes [x, y], <span class="hljs-keyword">and</span> that the query [x, y] <span class="hljs-keyword">is</span> equivalent to the query [y, x].
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>2 &lt;= n &lt;= 104</code></p></li>
<li><p><code>0 &lt;= threshold &lt;= n</code></p></li>
<li><p><code>1 &lt;= queries.length &lt;= 105</code></p></li>
<li><p><code>queries[i].length == 2</code></p></li>
<li><p><code>1 &lt;= ai, bi &lt;= cities</code></p></li>
<li><p><code>ai != bi</code></p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Boolean&gt; <span class="hljs-title">areConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> threshold, <span class="hljs-keyword">int</span>[][] queries)</span> </span>{
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span> || queries == <span class="hljs-keyword">null</span> || queries.length == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        }
        <span class="hljs-keyword">int</span> i;
        <span class="hljs-keyword">int</span> j;
        <span class="hljs-keyword">int</span> k;
        <span class="hljs-keyword">int</span> x;
        DisjointSetUnion set = <span class="hljs-keyword">new</span> DisjointSetUnion(n + <span class="hljs-number">1</span>);
        <span class="hljs-keyword">int</span> edges = queries.length;
        <span class="hljs-keyword">for</span> (i = threshold + <span class="hljs-number">1</span>; i &lt;= n; i++) {
            k = n / i;
            x = i;
            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">2</span>; j &lt;= k; j++) {
                x = x + i;
                set.union(i, x);
            }
        }
        List&lt;Boolean&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(edges);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] query : queries) {
            result.add(set.find(query[<span class="hljs-number">0</span>]) == set.find(query[<span class="hljs-number">1</span>]));
        }
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DisjointSetUnion</span> </span>{
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] rank;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] parent;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DisjointSetUnion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
            rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
            parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
                <span class="hljs-keyword">this</span>.rank[i] = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">this</span>.parent[i] = i;
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>{
            <span class="hljs-keyword">int</span> x = u;
            <span class="hljs-keyword">while</span> (x != parent[x]) {
                x = parent[x];
            }
            parent[u] = x;
            <span class="hljs-keyword">return</span> x;
        }

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>{
            <span class="hljs-keyword">if</span> (u != v) {
                <span class="hljs-keyword">int</span> x = find(u);
                <span class="hljs-keyword">int</span> y = find(v);
                <span class="hljs-keyword">if</span> (x != y) {
                    <span class="hljs-keyword">if</span> (rank[x] &gt; rank[y]) {
                        rank[x] += rank[y];
                        parent[y] = x;
                    } <span class="hljs-keyword">else</span> {
                        rank[y] += rank[x];
                        parent[x] = y;
                    }
                }
            }
        }
    }
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>