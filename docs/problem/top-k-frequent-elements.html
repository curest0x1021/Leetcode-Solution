<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Top K Frequent Elements - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://baffinlee.com/leetcode-javascript/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://baffinlee.com/leetcode-javascript/static/css/app.css"/></head><body><header><h1>347. Top K Frequent Elements</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://baffinlee.com/leetcode-javascript/difficulty/medium" class="tag">Medium</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://baffinlee.com/leetcode-javascript/tag/array">Array</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/hash-table">Hash Table</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/divide-and-conquer">Divide and Conquer</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/sorting">Sorting</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/heap-priority-queue">Heap (Priority Queue)</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/bucket-sort">Bucket Sort</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/counting">Counting</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/quickselect">Quickselect</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"><li><a href="https://baffinlee.com/leetcode-javascript/problem/word-frequency.html">Word Frequency</a></li><li><a href="https://baffinlee.com/leetcode-javascript/problem/kth-largest-element-in-an-array.html">Kth Largest Element in an Array</a></li><li><a href="https://baffinlee.com/leetcode-javascript/problem/sort-characters-by-frequency.html">Sort Characters By Frequency</a></li><li><a href="https://baffinlee.com/leetcode-javascript/problem/split-array-into-consecutive-subsequences.html">Split Array into Consecutive Subsequences</a></li><li><a href="https://baffinlee.com/leetcode-javascript/problem/top-k-frequent-words.html">Top K Frequent Words</a></li><li><a href="https://baffinlee.com/leetcode-javascript/problem/k-closest-points-to-origin.html">K Closest Points to Origin</a></li><li><a href="https://baffinlee.com/leetcode-javascript/problem/sort-features-by-popularity.html">Sort Features by Popularity</a></li><li><a href="https://baffinlee.com/leetcode-javascript/problem/sender-with-largest-word-count.html">Sender With Largest Word Count</a></li></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <strong>the</strong> <code>k</code> <strong>most frequent elements</strong>. You may return the answer in <strong>any order</strong>.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<pre><code class="hljs">Input: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], k = <span class="hljs-number">2</span>
Output: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code class="hljs">Input: nums = [<span class="hljs-number">1</span>], k = <span class="hljs-number">1</span>
Output: [<span class="hljs-number">1</span>]
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>1 &lt;= nums.length &lt;= 105</code></p></li>
<li><p><code>-104 &lt;= nums[i] &lt;= 104</code></p></li>
<li><p><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</p></li>
<li><p>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</p></li>
</ul>
<p>&nbsp;
<strong>Follow up:</strong> Your algorithm's time complexity must be better than <code>O(n log n)</code>, where n is the array's size.</p>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-javascript"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param <span class="hljs-type">{number[]}</span> <span class="hljs-variable">nums</span></span>
 * <span class="hljs-doctag">@param <span class="hljs-type">{number}</span> <span class="hljs-variable">k</span></span>
 * <span class="hljs-doctag">@return <span class="hljs-type">{number[]}</span></span>
 */</span>
<span class="hljs-keyword">var</span> topKFrequent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>{
  <span class="hljs-comment">//1. build a hash map : {i =&gt; 2, love =&gt; 2, leetcode =&gt;1, coding =&gt; 1}</span>
  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  nums.forEach(<span class="hljs-function">(<span class="hljs-params">word</span>) =&gt;</span> map.set(word, map.get(word) + <span class="hljs-number">1</span> || <span class="hljs-number">1</span>));

  <span class="hljs-comment">//2. build a min-heap with k length (based on hashmap above)</span>
  <span class="hljs-keyword">let</span> minheap = <span class="hljs-keyword">new</span> MinHeap(k);
  <span class="hljs-keyword">let</span> arr = [];
  map.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>)=&gt;</span>{
    arr.push({
      <span class="hljs-attr">key</span>: key,
      <span class="hljs-attr">priority</span>: value
    })
  })
  minheap.build(arr);

 <span class="hljs-comment">//3. log out result</span>
  <span class="hljs-keyword">return</span> minheap.get().map(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item.key).reverse()
};

<span class="hljs-keyword">const</span> calcDistance =  <span class="hljs-function">(<span class="hljs-params">point</span>) =&gt;</span>  <span class="hljs-built_in">Math</span>.sqrt( <span class="hljs-built_in">Math</span>.pow(point[<span class="hljs-number">0</span>],<span class="hljs-number">2</span>) + <span class="hljs-built_in">Math</span>.pow(point[<span class="hljs-number">1</span>],<span class="hljs-number">2</span>) );

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span> </span>{
  <span class="hljs-keyword">constructor</span>(size, type) {
    <span class="hljs-keyword">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(size); <span class="hljs-comment">// SC: O(k)</span>
    <span class="hljs-keyword">this</span>.type = type;
  }

  size() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.data.length;
  }

  build(arr) {  <span class="hljs-comment">// O(nlogk)</span>
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.size(); i++) {
      <span class="hljs-keyword">this</span>.data[i] = arr[i]; <span class="hljs-comment">// O(k)</span>
    }

    <span class="hljs-comment">/* 
      this step is for bubble UP: 
      calling heapify function on all the parent nodes, 
      the for loop will iterate for each parent node from 
      indices (n - 2) / 2 to 0.
    */</span>
    <span class="hljs-keyword">for</span> (
      <span class="hljs-keyword">let</span> parentIdx = <span class="hljs-built_in">Math</span>.floor((<span class="hljs-keyword">this</span>.size() - <span class="hljs-number">1</span> - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);
      parentIdx &gt;= <span class="hljs-number">0</span>;
      --parentIdx
    ) {
      <span class="hljs-keyword">this</span>._heapify(parentIdx);   <span class="hljs-comment">// O(klogk)</span>
    }

    <span class="hljs-comment">/* 
      this step kinda like bubble down, 
      i start as heap size, end as input arr length 
    */</span>
    <span class="hljs-keyword">while</span> (i &lt; arr.length) { <span class="hljs-comment">// O((n - k) * logk)</span>
   <span class="hljs-comment">//if heap top is less than next entry, replace the heap top</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.compare(<span class="hljs-keyword">this</span>.data[<span class="hljs-number">0</span>], arr[i])) {
        <span class="hljs-keyword">this</span>.data[<span class="hljs-number">0</span>] = arr[i];
        <span class="hljs-keyword">this</span>._heapify(<span class="hljs-number">0</span>); <span class="hljs-comment">//ie: parentId is 0</span>
      }
      ++i;
    }

  }

  _heapify(idx) {
    <span class="hljs-comment">// O(logk)</span>
    <span class="hljs-keyword">const</span> leftIndex = <span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> rightIndex = <span class="hljs-number">2</span> * idx + <span class="hljs-number">2</span>;
    <span class="hljs-keyword">let</span> p = idx;

    <span class="hljs-keyword">if</span> (
      leftIndex &lt; <span class="hljs-keyword">this</span>.size() &amp;&amp;
      <span class="hljs-keyword">this</span>.compare(<span class="hljs-keyword">this</span>.data[leftIndex], <span class="hljs-keyword">this</span>.data[p])
    ) {
      p = leftIndex;
    }
    <span class="hljs-keyword">if</span> (
      rightIndex &lt; <span class="hljs-keyword">this</span>.size() &amp;&amp;
      <span class="hljs-keyword">this</span>.compare(<span class="hljs-keyword">this</span>.data[rightIndex], <span class="hljs-keyword">this</span>.data[p])
    ) {
      p = rightIndex;
    }
    <span class="hljs-keyword">if</span> (p !== idx) {
      <span class="hljs-comment">// swap here</span>
      [<span class="hljs-keyword">this</span>.data[p], <span class="hljs-keyword">this</span>.data[idx]] = [<span class="hljs-keyword">this</span>.data[idx], <span class="hljs-keyword">this</span>.data[p]];
      <span class="hljs-keyword">this</span>._heapify(p);
    }
  }

  compare(a, b) { <span class="hljs-comment">// O(1)</span>
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.type) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"MIN"</span>: <span class="hljs-comment">// MinHeap</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">"object"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">"object"</span>) {
          <span class="hljs-comment">// a,b are number, string etc..</span>
          <span class="hljs-keyword">return</span> a &lt; b;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// a and b structor is {key: '' , priority: 1}</span>
          <span class="hljs-comment">// if freq of a &lt; freq of b OR if freq is same but a is lexicographically greater than b then a should be the parent node</span>
          <span class="hljs-keyword">return</span> (
            a.priority &lt; b.priority ||
            (a.priority === b.priority &amp;&amp; a.key &gt; b.key)
          );
        }
      <span class="hljs-keyword">case</span> <span class="hljs-string">"MAX"</span>: <span class="hljs-comment">//MaxHeap</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">"object"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">"object"</span>) {
          <span class="hljs-keyword">return</span> a &gt; b;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> (
            <span class="hljs-comment">// if freq of a &gt; freq of b OR if freq is same but a is lexicographically smaller than b then a should be the parent node</span>
            a.priority &gt; b.priority ||
            (a.priority === b.priority &amp;&amp; a.key &lt; b.key)
          );
        }
      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
    }
  }

  <span class="hljs-keyword">get</span>() {
    <span class="hljs-comment">// until the heap is empty, create the resultant array by removing elements from the top</span>
    <span class="hljs-keyword">const</span> result = [];
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.size()) {
      <span class="hljs-keyword">const</span> top = <span class="hljs-keyword">this</span>.data[<span class="hljs-number">0</span>];
      [<span class="hljs-keyword">this</span>.data[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.data[<span class="hljs-keyword">this</span>.size() - <span class="hljs-number">1</span>]] = [
        <span class="hljs-keyword">this</span>.data[<span class="hljs-keyword">this</span>.size() - <span class="hljs-number">1</span>],
        <span class="hljs-keyword">this</span>.data[<span class="hljs-number">0</span>]
      ];
      <span class="hljs-keyword">this</span>.data.pop();
      <span class="hljs-keyword">this</span>._heapify(<span class="hljs-number">0</span>);
      result.push(top);
    }
    <span class="hljs-keyword">return</span> result;
  }

  insert(item) {
    <span class="hljs-keyword">this</span>.data.push(item);
    <span class="hljs-keyword">this</span>.build(<span class="hljs-keyword">this</span>.data);
  }

  removeRoot() {
    <span class="hljs-keyword">let</span> root = <span class="hljs-keyword">this</span>.data[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">let</span> last = <span class="hljs-keyword">this</span>.data.pop();

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.data.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.data[<span class="hljs-number">0</span>] = last;
      <span class="hljs-keyword">this</span>.build(<span class="hljs-keyword">this</span>.data);
    }
    <span class="hljs-keyword">return</span> root;
  }

  peek() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.data[<span class="hljs-number">0</span>];
  }

}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinHeap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Heap</span> </span>{
  <span class="hljs-keyword">constructor</span>(size) {
    <span class="hljs-keyword">super</span>(size, <span class="hljs-string">"MIN"</span>);
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxHeap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Heap</span> </span>{
  <span class="hljs-keyword">constructor</span>(size) {
    <span class="hljs-keyword">super</span>(size, <span class="hljs-string">"MAX"</span>);
  }
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/BaffinLee/leetcode-javascript" target="_blank"><img src="https://baffinlee.com/leetcode-javascript/static/img/github.png" alt="github"/></a></footer></body></html>