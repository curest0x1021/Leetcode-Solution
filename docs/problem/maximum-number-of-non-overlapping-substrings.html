<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Maximum Number of Non-Overlapping Substrings - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>1520. Maximum Number of Non-Overlapping Substrings</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/string">String</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/greedy">Greedy</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>Given a string <code>s</code> of lowercase letters, you need to find the maximum number of <strong>non-empty</strong> substrings of <code>s</code> that meet the following conditions:</p>
<ul>
<li><p>The substrings do not overlap, that is for any two substrings <code>s[i..j]</code> and <code>s[x..y]</code>, either <code>j &lt; x</code> or <code>i &gt; y</code> is true.</p></li>
<li><p>A substring that contains a certain character <code>c</code> must also contain all occurrences of <code>c</code>.</p></li>
</ul>
<p>Find <strong>the maximum number of substrings that meet the above conditions</strong>. If there are multiple solutions with the same number of substrings, **return the one with minimum total length. **It can be shown that there exists a unique solution of minimum total length.</p>
<p>Notice that you can return the substrings in <strong>any</strong> order.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<pre><code class="hljs">Input: s = <span class="hljs-string">"adefaddaccc"</span>
Output: [<span class="hljs-string">"e"</span>,<span class="hljs-string">"f"</span>,<span class="hljs-string">"ccc"</span>]
Explanation:&amp;nbsp;The following are all <span class="hljs-keyword">the</span> possible substrings <span class="hljs-keyword">that</span> meet <span class="hljs-keyword">the</span> conditions:
[
&amp;nbsp; <span class="hljs-string">"adefaddaccc"</span>
&amp;nbsp; <span class="hljs-string">"adefadda"</span>,
&amp;nbsp; <span class="hljs-string">"ef"</span>,
&amp;nbsp; <span class="hljs-string">"e"</span>,
  <span class="hljs-string">"f"</span>,
&amp;nbsp; <span class="hljs-string">"ccc"</span>,
]
If we choose <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> <span class="hljs-built_in">string</span>, we cannot choose anything <span class="hljs-keyword">else</span> <span class="hljs-keyword">and</span> we'd <span class="hljs-keyword">get</span> only <span class="hljs-number">1.</span> If we choose <span class="hljs-string">"adefadda"</span>, we are left <span class="hljs-keyword">with</span> <span class="hljs-string">"ccc"</span> which <span class="hljs-keyword">is</span> <span class="hljs-keyword">the</span> only one <span class="hljs-keyword">that</span> doesn't overlap, thus obtaining <span class="hljs-number">2</span> substrings. Notice also, <span class="hljs-keyword">that</span> <span class="hljs-keyword">it</span>'s <span class="hljs-keyword">not</span> optimal <span class="hljs-keyword">to</span> choose <span class="hljs-string">"ef"</span> <span class="hljs-keyword">since</span> <span class="hljs-keyword">it</span> can be split <span class="hljs-keyword">into</span> two. Therefore, <span class="hljs-keyword">the</span> optimal way <span class="hljs-keyword">is</span> <span class="hljs-keyword">to</span> choose [<span class="hljs-string">"e"</span>,<span class="hljs-string">"f"</span>,<span class="hljs-string">"ccc"</span>] which gives us <span class="hljs-number">3</span> substrings. No other solution <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> same <span class="hljs-built_in">number</span> <span class="hljs-keyword">of</span> substrings exist.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code class="hljs">Input: s = <span class="hljs-string">"abbaccd"</span>
Output: [<span class="hljs-string">"d"</span>,<span class="hljs-string">"bb"</span>,<span class="hljs-string">"cc"</span>]
Explanation: Notice <span class="hljs-keyword">that</span> <span class="hljs-keyword">while</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">of</span> substrings [<span class="hljs-string">"d"</span>,<span class="hljs-string">"abba"</span>,<span class="hljs-string">"cc"</span>] also has <span class="hljs-built_in">length</span> <span class="hljs-number">3</span>, <span class="hljs-keyword">it</span>'s considered incorrect <span class="hljs-keyword">since</span> <span class="hljs-keyword">it</span> has larger total <span class="hljs-built_in">length</span>.
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>1 &lt;= s.length &lt;= 105</code></p></li>
<li><p><code>s</code> contains only lowercase English letters.</p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">maxNumOfSubstrings</span><span class="hljs-params">(String s)</span> </span>{
        <span class="hljs-keyword">int</span>[] lefts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];
        <span class="hljs-keyword">int</span>[] rights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];
        Arrays.fill(lefts, -<span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) {
            <span class="hljs-keyword">int</span> idx = s.charAt(i) - <span class="hljs-string">'a'</span>;
            <span class="hljs-keyword">if</span> (lefts[idx] == -<span class="hljs-number">1</span>) {
                lefts[idx] = i;
            }
            rights[idx] = i;
        }
        List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        Deque&lt;<span class="hljs-keyword">int</span>[]&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();
        <span class="hljs-keyword">int</span>[] top = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) {
            <span class="hljs-keyword">int</span> idx = s.charAt(i) - <span class="hljs-string">'a'</span>;
            <span class="hljs-keyword">if</span> (i == lefts[idx]) {
                <span class="hljs-keyword">if</span> (top == <span class="hljs-keyword">null</span> || rights[idx] &lt; top[<span class="hljs-number">1</span>]) {
                    top = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] {i, rights[idx]};
                    stack.offerFirst(top);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rights[idx] &gt; top[<span class="hljs-number">1</span>]) {
                    top[<span class="hljs-number">1</span>] = rights[idx];
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (top != <span class="hljs-keyword">null</span> &amp;&amp; lefts[idx] &lt; top[<span class="hljs-number">0</span>]) {
                <span class="hljs-keyword">int</span> newEnd = rights[idx];
                <span class="hljs-keyword">while</span> (top != <span class="hljs-keyword">null</span> &amp;&amp; top[<span class="hljs-number">0</span>] &gt; lefts[idx]) {
                    newEnd = Math.max(newEnd, top[<span class="hljs-number">1</span>]);
                    stack.pollFirst();
                    top = stack.peekFirst();
                }
                <span class="hljs-keyword">if</span> (top != <span class="hljs-keyword">null</span>) {
                    top[<span class="hljs-number">1</span>] = Math.max(newEnd, top[<span class="hljs-number">1</span>]);
                }
            }
            <span class="hljs-keyword">if</span> (top != <span class="hljs-keyword">null</span> &amp;&amp; i &gt;= top[<span class="hljs-number">1</span>]) {
                result.add(s.substring(top[<span class="hljs-number">0</span>], top[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>));
                stack.clear();
                top = <span class="hljs-keyword">null</span>;
            }
        }
        <span class="hljs-keyword">return</span> result;
    }
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>