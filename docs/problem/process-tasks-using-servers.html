<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Process Tasks Using Servers - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>1882. Process Tasks Using Servers</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/medium" class="tag">Medium</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/array">Array</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/heap-priority-queue">Heap (Priority Queue)</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/parallel-courses-iii.html">Parallel Courses III</a></li></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>You are given two <strong>0-indexed</strong> integer arrays <code>servers</code> and <code>tasks</code> of lengths <code>n</code>​​​​​​ and <code>m</code>​​​​​​ respectively. <code>servers[i]</code> is the <strong>weight</strong> of the <code>i​​​​​​th</code>​​​​ server, and <code>tasks[j]</code> is the <strong>time needed</strong> to process the <code>j​​​​​​th</code>​​​​ task <strong>in seconds</strong>.</p>
<p>Tasks are assigned to the servers using a <strong>task queue</strong>. Initially, all servers are free, and the queue is <strong>empty</strong>.</p>
<p>At second <code>j</code>, the <code>jth</code> task is <strong>inserted</strong> into the queue (starting with the <code>0th</code> task being inserted at second <code>0</code>). As long as there are free servers and the queue is not empty, the task in the front of the queue will be assigned to a free server with the <strong>smallest weight</strong>, and in case of a tie, it is assigned to a free server with the <strong>smallest index</strong>.</p>
<p>If there are no free servers and the queue is not empty, we wait until a server becomes free and immediately assign the next task. If multiple servers become free at the same time, then multiple tasks from the queue will be assigned <strong>in order of insertion</strong> following the weight and index priorities above.</p>
<p>A server that is assigned task <code>j</code> at second <code>t</code> will be free again at second <code>t + tasks[j]</code>.</p>
<p>Build an array <code>ans</code>​​​​ of length <code>m</code>, where <code>ans[j]</code> is the <strong>index</strong> of the server the <code>j​​​​​​th</code> task will be assigned to.</p>
<p>Return **the array **<code>ans</code>​​​​.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<pre><code class="hljs">Input: servers = [3,3,2], tasks = [1,2,3,2,1,2]
Output: [2,2,0,2,1,2]
Explanation: Events <span class="hljs-keyword">in</span> chronological order go as follows:
- At second 0, task 0 is added <span class="hljs-keyword">and</span> processed using<span class="hljs-built_in"> server </span>2 until second 1.
- At second 1,<span class="hljs-built_in"> server </span>2 becomes free. Task 1 is added <span class="hljs-keyword">and</span> processed using<span class="hljs-built_in"> server </span>2 until second 3.
- At second 2, task 2 is added <span class="hljs-keyword">and</span> processed using<span class="hljs-built_in"> server </span>0 until second 5.
- At second 3,<span class="hljs-built_in"> server </span>2 becomes free. Task 3 is added <span class="hljs-keyword">and</span> processed using<span class="hljs-built_in"> server </span>2 until second 5.
- At second 4, task 4 is added <span class="hljs-keyword">and</span> processed using<span class="hljs-built_in"> server </span>1 until second 5.
- At second 5, all servers become free. Task 5 is added <span class="hljs-keyword">and</span> processed using<span class="hljs-built_in"> server </span>2 until second 7.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code class="hljs">Input: servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]
Output: [1,4,1,4,1,3,2]
Explanation: Events <span class="hljs-keyword">in</span> chronological order go as follows: 
- At second 0, task 0 is added <span class="hljs-keyword">and</span> processed using<span class="hljs-built_in"> server </span>1 until second 2.
- At second 1, task 1 is added <span class="hljs-keyword">and</span> processed using<span class="hljs-built_in"> server </span>4 until second 2.
- At second 2, servers 1 <span class="hljs-keyword">and</span> 4 become free. Task 2 is added <span class="hljs-keyword">and</span> processed using<span class="hljs-built_in"> server </span>1 until second 4. 
- At second 3, task 3 is added <span class="hljs-keyword">and</span> processed using<span class="hljs-built_in"> server </span>4 until second 7.
- At second 4,<span class="hljs-built_in"> server </span>1 becomes free. Task 4 is added <span class="hljs-keyword">and</span> processed using<span class="hljs-built_in"> server </span>1 until second 9. 
- At second 5, task 5 is added <span class="hljs-keyword">and</span> processed using<span class="hljs-built_in"> server </span>3 until second 7.
- At second 6, task 6 is added <span class="hljs-keyword">and</span> processed using<span class="hljs-built_in"> server </span>2 until second 7.
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>servers.length == n</code></p></li>
<li><p><code>tasks.length == m</code></p></li>
<li><p><code>1 &lt;= n, m &lt;= 2 * 105</code></p></li>
<li><p><code>1 &lt;= servers[i], tasks[j] &lt;= 2 * 105</code></p></li>
</ul>
<h2 id="solution-java">Solution (Java)</h2>
<pre><code class="hljs lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] assignTasks(<span class="hljs-keyword">int</span>[] servers, <span class="hljs-keyword">int</span>[] tasks) {
        PriorityQueue&lt;Integer&gt; serverq =
                <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(
                        (i1, i2) -&gt;
                                servers[i1] != servers[i2] ? servers[i1] - servers[i2] : i1 - i2);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; servers.length; i++) {
            serverq.offer(i);
        }
        PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt; activetaskq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((i1, i2) -&gt; i1[<span class="hljs-number">1</span>] - i2[<span class="hljs-number">1</span>]);
        <span class="hljs-keyword">int</span> time = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[tasks.length];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tasks.length; i++) {
            time = Math.max(time, i);
            <span class="hljs-keyword">while</span> (!activetaskq.isEmpty() &amp;&amp; activetaskq.peek()[<span class="hljs-number">1</span>] &lt;= i) {
                <span class="hljs-keyword">int</span>[] task = activetaskq.poll();
                serverq.offer(task[<span class="hljs-number">0</span>]);
            }
            <span class="hljs-keyword">if</span> (serverq.isEmpty()) {
                <span class="hljs-keyword">int</span>[] toptask = activetaskq.peek();
                <span class="hljs-keyword">while</span> (!activetaskq.isEmpty() &amp;&amp; activetaskq.peek()[<span class="hljs-number">1</span>] == toptask[<span class="hljs-number">1</span>]) {
                    <span class="hljs-keyword">int</span>[] task = activetaskq.poll();
                    serverq.offer(task[<span class="hljs-number">0</span>]);
                }
                time = toptask[<span class="hljs-number">1</span>];
            }
            <span class="hljs-keyword">int</span> server = serverq.poll();
            res[i] = server;
            activetaskq.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] {server, time + tasks[i]});
        }
        <span class="hljs-keyword">return</span> res;
    }
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>