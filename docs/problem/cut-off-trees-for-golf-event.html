<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Cut Off Trees for Golf Event - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>675. Cut Off Trees for Golf Event</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/array">Array</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/breadth-first-search">Breadth-First Search</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/heap-priority-queue">Heap (Priority Queue)</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/matrix">Matrix</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an <code>m x n</code> matrix. In this matrix:</p>
<ul>
<li><p><code>0</code> means the cell cannot be walked through.</p></li>
<li><p><code>1</code> represents an empty cell that can be walked through.</p></li>
<li><p>A number greater than <code>1</code> represents a tree in a cell that can be walked through, and this number is the tree's height.</p></li>
</ul>
<p>In one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.</p>
<p>You must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes <code>1</code> (an empty cell).</p>
<p>Starting from the point <code>(0, 0)</code>, return <strong>the minimum steps you need to walk to cut off all the trees</strong>. If you cannot cut off all the trees, return <code>-1</code>.</p>
<p><strong>Note:</strong> The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg" alt="" /></p>
<pre><code class="hljs">Input: forest = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>]]
Output: <span class="hljs-number">6</span>
Explanation: Following the path above allows you to cut off the trees <span class="hljs-keyword">from</span> shortest to tallest <span class="hljs-keyword">in</span> <span class="hljs-number">6</span> steps.
</code></pre>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg" alt="" /></p>
<pre><code class="hljs">Input: forest = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>]]
Output: <span class="hljs-number">-1</span>
Explanation: The trees <span class="hljs-keyword">in</span> the bottom row cannot be accessed as the middle row <span class="hljs-keyword">is</span> blocked.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code class="hljs">Input: forest = [[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>]]
Output: <span class="hljs-number">6</span>
Explanation: You can follow the same path as Example <span class="hljs-number">1</span> to cut off all the trees.
Note that you can cut off the first tree at (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) before making any steps.
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>m == forest.length</code></p></li>
<li><p><code>n == forest[i].length</code></p></li>
<li><p><code>1 &lt;= m, n &lt;= 50</code></p></li>
<li><p><code>0 &lt;= forest[i][j] &lt;= 109</code></p></li>
<li><p>Heights of all trees are <strong>distinct</strong>.</p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-javascript"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param <span class="hljs-type">{number[][]}</span> <span class="hljs-variable">forest</span></span>
 * <span class="hljs-doctag">@return <span class="hljs-type">{number}</span></span>
 */</span>
<span class="hljs-keyword">var</span> cutOffTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">forest</span>) </span>{
    <span class="hljs-keyword">const</span> trees = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> row = <span class="hljs-number">0</span>; row &lt; forest.length; row ++ ) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> col = <span class="hljs-number">0</span>; col &lt; forest[<span class="hljs-number">0</span>].length; col++ ) {
            <span class="hljs-keyword">if</span>(forest[row][col] &gt;<span class="hljs-number">1</span>) trees.push(forest[row][col])
        }
    };    
    trees.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>{ <span class="hljs-keyword">return</span> a &gt; b ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>});

    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> found;
    <span class="hljs-keyword">let</span> startPosition = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>];
    <span class="hljs-keyword">let</span> visited = {};
    <span class="hljs-keyword">let</span> key, current;
    <span class="hljs-keyword">let</span> row, col
    <span class="hljs-keyword">let</span> stack = [];
    <span class="hljs-keyword">let</span> nextStack = []
    <span class="hljs-keyword">let</span> target

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i &lt;trees.length; i++) {
        target = trees[i]
        visited = {};
        nextStack = [startPosition];
        count--; <span class="hljs-comment">//so we don't count the starting position of each iteration</span>

        <span class="hljs-keyword">while</span> (nextStack.length &amp;&amp; !found) {
           stack = nextStack;
           nextStack = [] 
           count++;
           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>; j &lt;stack.length; j++) {
                [row, col] = stack[j];
                key = <span class="hljs-string">`<span class="hljs-subst">${row}</span>:<span class="hljs-subst">${col}</span>`</span>;

                <span class="hljs-keyword">if</span>(!forest[row] || !forest[row][col]) <span class="hljs-keyword">continue</span>
                <span class="hljs-keyword">if</span>(found || visited[key]) <span class="hljs-keyword">continue</span>;

                visited[key] = <span class="hljs-literal">true</span>;
                current = forest[row][col];

                <span class="hljs-keyword">if</span>(current === target) {
                    found = <span class="hljs-literal">true</span>;
                    startPosition = [row,col];
                    <span class="hljs-keyword">break</span>;
                } <span class="hljs-keyword">else</span> {
                    nextStack.push([row+<span class="hljs-number">1</span>, col]);
                    nextStack.push([row<span class="hljs-number">-1</span>, col]);
                    nextStack.push([row, col+<span class="hljs-number">1</span>]);
                    nextStack.push([row, col<span class="hljs-number">-1</span>]);
                }
            };

        }

        <span class="hljs-keyword">if</span>(!found) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        found = <span class="hljs-literal">false</span>;
    };

    <span class="hljs-keyword">return</span> count;
};
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>