<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Longest Cycle in a Graph - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>2360. Longest Cycle in a Graph</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/depth-first-search">Depth-First Search</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/graph">Graph</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/topological-sort">Topological Sort</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/strange-printer-ii.html">Strange Printer II</a></li></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>You are given a <strong>directed</strong> graph of <code>n</code> nodes numbered from <code>0</code> to <code>n - 1</code>, where each node has <strong>at most one</strong> outgoing edge.</p>
<p>The graph is represented with a given <strong>0-indexed</strong> array <code>edges</code> of size <code>n</code>, indicating that there is a directed edge from node <code>i</code> to node <code>edges[i]</code>. If there is no outgoing edge from node <code>i</code>, then <code>edges[i] == -1</code>.</p>
<p>Return **the length of the *<em>longest</em>* cycle in the graph**. If no cycle exists, return <code>-1</code>.</p>
<p>A cycle is a path that starts and ends at the <strong>same</strong> node.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/06/08/graph4drawio-5.png" alt="" /></p>
<pre><code class="hljs">Input: edges = [<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
Output: <span class="hljs-number">3</span>
Explanation: The longest cycle <span class="hljs-keyword">in</span> the graph <span class="hljs-keyword">is</span> the cycle: <span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span> -&gt; <span class="hljs-number">2.</span>
The length of <span class="hljs-keyword">this</span> cycle <span class="hljs-keyword">is</span> <span class="hljs-number">3</span>, so <span class="hljs-number">3</span> <span class="hljs-keyword">is</span> returned.
</code></pre>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-1.png" alt="" /></p>
<pre><code class="hljs">Input: edges = [<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]
Output: <span class="hljs-number">-1</span>
Explanation: There are no cycles <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span> graph.
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>n == edges.length</code></p></li>
<li><p><code>2 &lt;= n &lt;= 105</code></p></li>
<li><p><code>-1 &lt;= edges[i] &lt; n</code></p></li>
<li><p><code>edges[i] != i</code></p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCycle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] edges)</span> </span>{
        <span class="hljs-keyword">int</span> n = edges.length;
        <span class="hljs-keyword">boolean</span>[] vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];
        <span class="hljs-keyword">boolean</span>[] dfsvis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];
        <span class="hljs-keyword">int</span>[] path = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
        <span class="hljs-keyword">int</span> maxLength = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">if</span> (!vis[i]) {
                path[i] = <span class="hljs-number">1</span>;
                maxLength = Math.max(maxLength, dfs(i, <span class="hljs-number">1</span>, path, vis, dfsvis, edges));
            }
        }
        <span class="hljs-keyword">return</span> maxLength;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(
            <span class="hljs-keyword">int</span> node, <span class="hljs-keyword">int</span> pathLength, <span class="hljs-keyword">int</span>[] path, <span class="hljs-keyword">boolean</span>[] vis, <span class="hljs-keyword">boolean</span>[] dfsvis, <span class="hljs-keyword">int</span>[] edges)</span> </span>{
        vis[node] = <span class="hljs-keyword">true</span>;
        dfsvis[node] = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">int</span> length = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (edges[node] != -<span class="hljs-number">1</span> &amp;&amp; !vis[edges[node]]) {
            path[edges[node]] = pathLength + <span class="hljs-number">1</span>;
            length = dfs(edges[node], pathLength + <span class="hljs-number">1</span>, path, vis, dfsvis, edges);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (edges[node] != -<span class="hljs-number">1</span> &amp;&amp; dfsvis[edges[node]]) {
            length = pathLength - path[edges[node]] + <span class="hljs-number">1</span>;
        }
        dfsvis[node] = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">return</span> length;
    }
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>