<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Maximum Good People Based on Statements - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>2151. Maximum Good People Based on Statements</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/array">Array</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/backtracking">Backtracking</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/bit-manipulation">Bit Manipulation</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/enumeration">Enumeration</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/maximum-score-words-formed-by-letters.html">Maximum Score Words Formed by Letters</a></li></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>There are two types of persons:</p>
<ul>
<li><p>The <strong>good person</strong>: The person who always tells the truth.</p></li>
<li><p>The <strong>bad person</strong>: The person who might tell the truth and might lie.</p></li>
</ul>
<p>You are given a <strong>0-indexed</strong> 2D integer array <code>statements</code> of size <code>n x n</code> that represents the statements made by <code>n</code> people about each other. More specifically, <code>statements[i][j]</code> could be one of the following:</p>
<ul>
<li><p><code>0</code> which represents a statement made by person <code>i</code> that person <code>j</code> is a <strong>bad</strong> person.</p></li>
<li><p><code>1</code> which represents a statement made by person <code>i</code> that person <code>j</code> is a <strong>good</strong> person.</p></li>
<li><p><code>2</code> represents that <strong>no statement</strong> is made by person <code>i</code> about person <code>j</code>.</p></li>
</ul>
<p>Additionally, no person ever makes a statement about themselves. Formally, we have that <code>statements[i][i] = 2</code> for all <code>0 &lt;= i &lt; n</code>.</p>
<p>Return **the *<em>maximum</em>* number of people who can be <strong>good</strong> based on the statements made by the <strong><code>n</code></strong> people**.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/01/15/logic1.jpg" alt="" /></p>
<pre><code class="hljs">Input: statements = <span class="hljs-comment">[<span class="hljs-comment">[2,1,2]</span>,<span class="hljs-comment">[1,2,2]</span>,<span class="hljs-comment">[2,0,2]</span>]</span>
Output: 2
Explanation: Each <span class="hljs-keyword">person</span> makes a single statement.
- <span class="hljs-keyword">Person</span> 0 states that <span class="hljs-keyword">person</span> 1 <span class="hljs-keyword">is</span> good.
- <span class="hljs-keyword">Person</span> 1 states that <span class="hljs-keyword">person</span> 0 <span class="hljs-keyword">is</span> good.
- <span class="hljs-keyword">Person</span> 2 states that <span class="hljs-keyword">person</span> 1 <span class="hljs-keyword">is</span> bad.
Let's take <span class="hljs-keyword">person</span> 2 as the key.
- Assuming that <span class="hljs-keyword">person</span> 2 <span class="hljs-keyword">is</span> a good <span class="hljs-keyword">person</span>:
    - Based on the statement made by <span class="hljs-keyword">person</span> 2, <span class="hljs-keyword">person</span> 1 <span class="hljs-keyword">is</span> a bad <span class="hljs-keyword">person</span>.
    - Now we know for sure that <span class="hljs-keyword">person</span> 1 <span class="hljs-keyword">is</span> bad and <span class="hljs-keyword">person</span> 2 <span class="hljs-keyword">is</span> good.
    - Based on the statement made by <span class="hljs-keyword">person</span> 1, and since <span class="hljs-keyword">person</span> 1 <span class="hljs-keyword">is</span> bad, they could be:
        - telling the truth. There will be a contradiction in this case and this assumption <span class="hljs-keyword">is</span> invalid.
        - lying. In this case, <span class="hljs-keyword">person</span> 0 <span class="hljs-keyword">is</span> also a bad <span class="hljs-keyword">person</span> and lied in their statement.
    - Following that <span class="hljs-keyword">person</span> 2 <span class="hljs-keyword">is</span> a good <span class="hljs-keyword">person</span>, there will be only one good <span class="hljs-keyword">person</span> in the group.
- Assuming that <span class="hljs-keyword">person</span> 2 <span class="hljs-keyword">is</span> a bad <span class="hljs-keyword">person</span>:
    - Based on the statement made by <span class="hljs-keyword">person</span> 2, and since <span class="hljs-keyword">person</span> 2 <span class="hljs-keyword">is</span> bad, they could be:
        - telling the truth. Following this scenario, <span class="hljs-keyword">person</span> 0 and 1 <span class="hljs-keyword">are</span> both bad as explained before.
            - Following that <span class="hljs-keyword">person</span> 2 <span class="hljs-keyword">is</span> bad but told the truth, there will be no good persons in the group.
        - lying. In this case <span class="hljs-keyword">person</span> 1 <span class="hljs-keyword">is</span> a good <span class="hljs-keyword">person</span>.
            - Since <span class="hljs-keyword">person</span> 1 <span class="hljs-keyword">is</span> a good <span class="hljs-keyword">person</span>, <span class="hljs-keyword">person</span> 0 <span class="hljs-keyword">is</span> also a good <span class="hljs-keyword">person</span>.
            - Following that <span class="hljs-keyword">person</span> 2 <span class="hljs-keyword">is</span> bad and lied, there will be two good persons in the group.
We can see that at most 2 persons <span class="hljs-keyword">are</span> good in the best case, so we return 2.
Note that there <span class="hljs-keyword">is</span> more than one way to arrive at this conclusion.
</code></pre>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/01/15/logic2.jpg" alt="" /></p>
<pre><code class="hljs">Input: statements = <span class="hljs-comment">[<span class="hljs-comment">[2,0]</span>,<span class="hljs-comment">[0,2]</span>]</span>
Output: 1
Explanation: Each <span class="hljs-keyword">person</span> makes a single statement.
- <span class="hljs-keyword">Person</span> 0 states that <span class="hljs-keyword">person</span> 1 <span class="hljs-keyword">is</span> bad.
- <span class="hljs-keyword">Person</span> 1 states that <span class="hljs-keyword">person</span> 0 <span class="hljs-keyword">is</span> bad.
Let's take <span class="hljs-keyword">person</span> 0 as the key.
- Assuming that <span class="hljs-keyword">person</span> 0 <span class="hljs-keyword">is</span> a good <span class="hljs-keyword">person</span>:
    - Based on the statement made by <span class="hljs-keyword">person</span> 0, <span class="hljs-keyword">person</span> 1 <span class="hljs-keyword">is</span> a bad <span class="hljs-keyword">person</span> and was lying.
    - Following that <span class="hljs-keyword">person</span> 0 <span class="hljs-keyword">is</span> a good <span class="hljs-keyword">person</span>, there will be only one good <span class="hljs-keyword">person</span> in the group.
- Assuming that <span class="hljs-keyword">person</span> 0 <span class="hljs-keyword">is</span> a bad <span class="hljs-keyword">person</span>:
    - Based on the statement made by <span class="hljs-keyword">person</span> 0, and since <span class="hljs-keyword">person</span> 0 <span class="hljs-keyword">is</span> bad, they could be:
        - telling the truth. Following this scenario, <span class="hljs-keyword">person</span> 0 and 1 <span class="hljs-keyword">are</span> both bad.
            - Following that <span class="hljs-keyword">person</span> 0 <span class="hljs-keyword">is</span> bad but told the truth, there will be no good persons in the group.
        - lying. In this case <span class="hljs-keyword">person</span> 1 <span class="hljs-keyword">is</span> a good <span class="hljs-keyword">person</span>.
            - Following that <span class="hljs-keyword">person</span> 0 <span class="hljs-keyword">is</span> bad and lied, there will be only one good <span class="hljs-keyword">person</span> in the group.
We can see that at most, one <span class="hljs-keyword">person</span> <span class="hljs-keyword">is</span> good in the best case, so we return 1.
Note that there <span class="hljs-keyword">is</span> more than one way to arrive at this conclusion.
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>n == statements.length == statements[i].length</code></p></li>
<li><p><code>2 &lt;= n &lt;= 15</code></p></li>
<li><p><code>statements[i][j]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</p></li>
<li><p><code>statements[i][i] == 2</code></p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximumGood</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] statements)</span> </span>{
        <span class="hljs-keyword">int</span>[] known = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[statements.length];
        Arrays.fill(known, <span class="hljs-number">2</span>);
        <span class="hljs-keyword">return</span> max(statements, known, <span class="hljs-number">0</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] statements, <span class="hljs-keyword">int</span>[] known, <span class="hljs-keyword">int</span> position)</span> </span>{
        <span class="hljs-keyword">if</span> (position == statements.length) {
            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) Arrays.stream(known).filter(a -&gt; a == <span class="hljs-number">1</span>).count();
        }
        <span class="hljs-keyword">switch</span> (known[position]) {
            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                <span class="hljs-keyword">return</span> assumeBad(statements, known, position);
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span> assumeGood(statements, known, position);
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">return</span> Math.max(
                        assumeBad(statements, known, position),
                        assumeGood(statements, known, position));
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">assumeBad</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] statements, <span class="hljs-keyword">int</span>[] known, <span class="hljs-keyword">int</span> position)</span> </span>{
        <span class="hljs-keyword">int</span>[] updatedKnown = known.clone();
        updatedKnown[position] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> max(statements, updatedKnown, position + <span class="hljs-number">1</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">assumeGood</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] statements, <span class="hljs-keyword">int</span>[] known, <span class="hljs-keyword">int</span> position)</span> </span>{
        <span class="hljs-keyword">int</span>[] updatedKnown = known.clone();
        <span class="hljs-keyword">boolean</span> conflictDetected = <span class="hljs-keyword">false</span>;
        updatedKnown[position] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; statements[position].length; i++) {
            <span class="hljs-keyword">int</span> answer = statements[position][i];
            <span class="hljs-keyword">if</span> (answer != <span class="hljs-number">2</span>) {
                <span class="hljs-keyword">if</span> (known[i] != <span class="hljs-number">2</span> &amp;&amp; answer != known[i]) {
                    conflictDetected = <span class="hljs-keyword">true</span>;
                    <span class="hljs-keyword">break</span>;
                }
                updatedKnown[i] = answer;
            }
        }
        <span class="hljs-keyword">return</span> conflictDetected ? <span class="hljs-number">0</span> : max(statements, updatedKnown, position + <span class="hljs-number">1</span>);
    }
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>