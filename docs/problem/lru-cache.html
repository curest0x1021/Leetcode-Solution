<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>LRU Cache - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>146. LRU Cache</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/design">Design</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/lfu-cache.html">LFU Cache</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/design-in-memory-file-system.html">Design In-Memory File System</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/design-compressed-string-iterator.html">Design Compressed String Iterator</a></li></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code>get</code> and <code>put</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
<code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p><strong>Follow up:</strong>
Could you do both operations in <strong>O(1)</strong> time complexity?</p>
<p><strong>Example:</strong></p>
<pre><code class="hljs">LRUCache <span class="hljs-keyword">cache</span> = new LRUCache( <span class="hljs-number">2</span> <span class="hljs-comment">/* capacity */</span> );

<span class="hljs-keyword">cache</span>.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">cache</span>.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
<span class="hljs-keyword">cache</span>.get(<span class="hljs-number">1</span>);       // <span class="hljs-keyword">returns</span> <span class="hljs-number">1</span>
<span class="hljs-keyword">cache</span>.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);    // evicts key <span class="hljs-number">2</span>
<span class="hljs-keyword">cache</span>.get(<span class="hljs-number">2</span>);       // <span class="hljs-keyword">returns</span> <span class="hljs-number">-1</span> (<span class="hljs-keyword">not</span> <span class="hljs-built_in">found</span>)
<span class="hljs-keyword">cache</span>.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);    // evicts key <span class="hljs-number">1</span>
<span class="hljs-keyword">cache</span>.get(<span class="hljs-number">1</span>);       // <span class="hljs-keyword">returns</span> <span class="hljs-number">-1</span> (<span class="hljs-keyword">not</span> <span class="hljs-built_in">found</span>)
<span class="hljs-keyword">cache</span>.get(<span class="hljs-number">3</span>);       // <span class="hljs-keyword">returns</span> <span class="hljs-number">3</span>
<span class="hljs-keyword">cache</span>.get(<span class="hljs-number">4</span>);       // <span class="hljs-keyword">returns</span> <span class="hljs-number">4</span>
</code></pre>
<h2 id="solution-java">Solution (Java)</h2>
<pre><code class="hljs lang-java"><span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LruCacheNode</span> </span>{
        <span class="hljs-keyword">int</span> key;
        <span class="hljs-keyword">int</span> value;
        LruCacheNode prev;
        LruCacheNode next;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LruCacheNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> v)</span> </span>{
            key = k;
            value = v;
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;
    <span class="hljs-keyword">private</span> Map&lt;Integer, LruCacheNode&gt; cacheMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-comment">// insert here</span>
    <span class="hljs-keyword">private</span> LruCacheNode head;
    <span class="hljs-comment">// remove here</span>
    <span class="hljs-keyword">private</span> LruCacheNode tail;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>{
        capacity = cap;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>{
        LruCacheNode val = cacheMap.get(key);
        <span class="hljs-keyword">if</span> (val == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
        moveToHead(val);
        <span class="hljs-keyword">return</span> val.value;
    }

    <span class="hljs-comment">/*
     * Scenarios :
     * 1. Value key is already present.
     *          update
     *          move node to head
     * 2. cache is not full
     *          cache is empty (create node and assign head and tail)
     *          cache is partially empty (add node to head and update head pointer)
     * 3. cache is full
     *          remove node at tail, update head, tail pointers
     *          Recursively call put
     *
     *
     * move node to head Scenarios
     * 1. node is at head
     * 2. node is at tail
     * 3. node is in middle
     *
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>{
        LruCacheNode valNode = cacheMap.get(key);
        <span class="hljs-keyword">if</span> (valNode != <span class="hljs-keyword">null</span>) {
            valNode.value = value;
            moveToHead(valNode);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (cacheMap.size() &lt; capacity) {
                <span class="hljs-keyword">if</span> (cacheMap.size() == <span class="hljs-number">0</span>) {
                    LruCacheNode node = <span class="hljs-keyword">new</span> LruCacheNode(key, value);
                    cacheMap.put(key, node);
                    head = node;
                    tail = node;
                } <span class="hljs-keyword">else</span> {
                    LruCacheNode node = <span class="hljs-keyword">new</span> LruCacheNode(key, value);
                    cacheMap.put(key, node);
                    node.next = head;
                    head.prev = node;
                    head = node;
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// remove from tail</span>
                LruCacheNode last = tail;
                tail = last.prev;
                <span class="hljs-keyword">if</span> (tail != <span class="hljs-keyword">null</span>) {
                    tail.next = <span class="hljs-keyword">null</span>;
                }
                cacheMap.remove(last.key);
                <span class="hljs-keyword">if</span> (cacheMap.size() == <span class="hljs-number">0</span>) {
                    head = <span class="hljs-keyword">null</span>;
                }
                <span class="hljs-comment">// Call recursively</span>
                put(key, value);
            }
        }
    }

    <span class="hljs-comment">/*
     * check for 3 conditions
     * 1. node is already at head
     * 2. Node is tail node
     * 3. Node in middle node
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(LruCacheNode node)</span> </span>{
        <span class="hljs-keyword">if</span> (node == head) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">if</span> (node == tail) {
            tail = node.prev;
        }
        <span class="hljs-comment">// node is not head, it should have some valid prev node</span>
        LruCacheNode prev = node.prev;
        LruCacheNode next = node.next;
        prev.next = next;
        <span class="hljs-keyword">if</span> (next != <span class="hljs-keyword">null</span>) {
            next.prev = prev;
        }
        node.prev = <span class="hljs-keyword">null</span>;
        node.next = head;
        head.prev = node;
        head = node;
    }
}

<span class="hljs-comment">/*
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */</span>
</code></pre>
<h2 id="solution-javascript">Solution (Javascript)</h2>
<pre><code class="hljs lang-javascript"><span class="hljs-keyword">var</span> List = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, val</span>) </span>{
  <span class="hljs-keyword">this</span>.key = key;
  <span class="hljs-keyword">this</span>.val = val;
  <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.prev = <span class="hljs-literal">null</span>;
};

<span class="hljs-comment">/**
 * @param {number} capacity
 */</span>
<span class="hljs-keyword">var</span> LRUCache = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">capacity</span>) </span>{
  <span class="hljs-keyword">this</span>.capacity = capacity;
  <span class="hljs-keyword">this</span>.length = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.map = {};
  <span class="hljs-keyword">this</span>.head = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.tail = <span class="hljs-literal">null</span>;
};

<span class="hljs-comment">/** 
 * @param {number} key
 * @return {number}
 */</span>
LRUCache.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.map[key];
  <span class="hljs-keyword">if</span> (node) {
    <span class="hljs-keyword">this</span>.remove(node);
    <span class="hljs-keyword">this</span>.insert(node.key, node.val);
    <span class="hljs-keyword">return</span> node.val;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }
};

<span class="hljs-comment">/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */</span>
LRUCache.prototype.put = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.map[key]) {
    <span class="hljs-keyword">this</span>.remove(<span class="hljs-keyword">this</span>.map[key]);
    <span class="hljs-keyword">this</span>.insert(key, value);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.length === <span class="hljs-keyword">this</span>.capacity) {
      <span class="hljs-keyword">this</span>.remove(<span class="hljs-keyword">this</span>.head);
      <span class="hljs-keyword">this</span>.insert(key, value);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.insert(key, value);
      <span class="hljs-keyword">this</span>.length++;
    }
  }
};

<span class="hljs-comment">/** 
 * Your LRUCache object will be instantiated and called as such:
 * var obj = Object.create(LRUCache).createNew(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */</span>

LRUCache.prototype.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">var</span> prev = node.prev;
  <span class="hljs-keyword">var</span> next = node.next;
  <span class="hljs-keyword">if</span> (next) next.prev = prev;
  <span class="hljs-keyword">if</span> (prev) prev.next = next;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.head === node) <span class="hljs-keyword">this</span>.head = next;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tail === node) <span class="hljs-keyword">this</span>.tail = prev;
  <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.map[node.key];
};

LRUCache.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, val</span>) </span>{
  <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> List(key, val);
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.tail) {
    <span class="hljs-keyword">this</span>.tail = node;
    <span class="hljs-keyword">this</span>.head = node;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.tail.next = node;
    node.prev = <span class="hljs-keyword">this</span>.tail;
    <span class="hljs-keyword">this</span>.tail = node;
  }
  <span class="hljs-keyword">this</span>.map[key] = node;
};
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(1).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>