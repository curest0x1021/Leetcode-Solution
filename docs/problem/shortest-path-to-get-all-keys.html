<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Shortest Path to Get All Keys - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://baffinlee.com/leetcode-javascript/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://baffinlee.com/leetcode-javascript/static/css/app.css"/></head><body><header><h1>864. Shortest Path to Get All Keys</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://baffinlee.com/leetcode-javascript/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://baffinlee.com/leetcode-javascript/tag/bit-manipulation">Bit Manipulation</a></li><li><a href="https://baffinlee.com/leetcode-javascript/tag/breadth-first-search">Breadth-First Search</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>You are given an <code>m x n</code> grid <code>grid</code> where:</p>
<ul>
<li><p><code>'.'</code> is an empty cell.</p></li>
<li><p><code>'#'</code> is a wall.</p></li>
<li><p><code>'@'</code> is the starting point.</p></li>
<li><p>Lowercase letters represent keys.</p></li>
<li><p>Uppercase letters represent locks.</p></li>
</ul>
<p>You start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.</p>
<p>If you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.</p>
<p>For some <code>1 &lt;= k &lt;= 6</code>, there is exactly one lowercase and one uppercase letter of the first <code>k</code> letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.</p>
<p>Return <strong>the lowest number of moves to acquire all keys</strong>. If it is impossible, return <code>-1</code>.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/07/23/lc-keys2.jpg" alt="" /></p>
<pre><code class="hljs">Input: grid = [<span class="hljs-string">"@.a.."</span>,<span class="hljs-string">"###.#"</span>,<span class="hljs-string">"b.A.B"</span>]
Output: 8
Explanation:<span class="hljs-built_in"> Note </span>that the goal is <span class="hljs-keyword">to</span> obtain all the keys <span class="hljs-keyword">not</span> <span class="hljs-keyword">to</span> open all the locks.
</code></pre>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/07/23/lc-key2.jpg" alt="" /></p>
<pre><code class="hljs"><span class="hljs-symbol">Input:</span> grid = [<span class="hljs-string">"@..aA"</span>,<span class="hljs-string">"..B#."</span>,<span class="hljs-string">"....b"</span>]
<span class="hljs-symbol">Output:</span> <span class="hljs-number">6</span>
</code></pre>
<p><strong>Example 3:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg" alt="" /></p>
<pre><code class="hljs"><span class="hljs-symbol">Input:</span> grid = [<span class="hljs-string">"@Aa"</span>]
<span class="hljs-symbol">Output:</span> <span class="hljs-number">-1</span>
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>m == grid.length</code></p></li>
<li><p><code>n == grid[i].length</code></p></li>
<li><p><code>1 &lt;= m, n &lt;= 30</code></p></li>
<li><p><code>grid[i][j]</code> is either an English letter, <code>'.'</code>, <code>'#'</code>, or <code>'@'</code>.</p></li>
<li><p>The number of keys in the grid is in the range <code>[1, 6]</code>.</p></li>
<li><p>Each key in the grid is <strong>unique</strong>.</p></li>
<li><p>Each key in the grid has a matching lock.</p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">shortestPathAllKeys</span><span class="hljs-params">(String[] stringGrid)</span> </span>{
        <span class="hljs-comment">// strategy: BFS + masking</span>
        m = stringGrid.length;
        n = stringGrid[<span class="hljs-number">0</span>].length();
        <span class="hljs-keyword">char</span>[][] grid = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[m][n];
        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// convert to char Array</span>
        <span class="hljs-keyword">for</span> (String s : stringGrid) {
            grid[index++] = s.toCharArray();
        }
        <span class="hljs-comment">// number of keys</span>
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
        Queue&lt;<span class="hljs-keyword">int</span>[]&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {
                <span class="hljs-comment">// find starting position</span>
                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">'@'</span>) {
                    q.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] {i, j, <span class="hljs-number">0</span>});
                }
                <span class="hljs-comment">// count number of keys</span>
                <span class="hljs-keyword">if</span> (<span class="hljs-string">'a'</span> &lt;= grid[i][j] &amp;&amp; grid[i][j] &lt;= <span class="hljs-string">'f'</span>) {
                    count++;
                }
            }
        }
        <span class="hljs-keyword">int</span>[] dx = {-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>};
        <span class="hljs-keyword">int</span>[] dy = {<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>};
        <span class="hljs-comment">// this is the amt of keys we need</span>
        <span class="hljs-keyword">int</span> target = (<span class="hljs-number">1</span> &lt;&lt; count) - <span class="hljs-number">1</span>;
        <span class="hljs-comment">// keep track of position and current state</span>
        <span class="hljs-keyword">boolean</span>[][][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n][target + <span class="hljs-number">1</span>];
        <span class="hljs-comment">// set initial position and state to true</span>
        visited[q.peek()[<span class="hljs-number">0</span>]][q.peek()[<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">int</span> steps = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (!q.isEmpty()) {
            <span class="hljs-comment">// use size to make sure everything is on one level</span>
            <span class="hljs-keyword">int</span> size = q.size();
            <span class="hljs-keyword">while</span> (--size &gt;= <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">int</span>[] curr = q.poll();
                <span class="hljs-keyword">int</span> x = curr[<span class="hljs-number">0</span>];
                <span class="hljs-keyword">int</span> y = curr[<span class="hljs-number">1</span>];
                <span class="hljs-keyword">int</span> state = curr[<span class="hljs-number">2</span>];
                <span class="hljs-comment">// found all keys</span>
                <span class="hljs-keyword">if</span> (state == target) {
                    <span class="hljs-keyword">return</span> steps;
                }
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {
                    <span class="hljs-keyword">int</span> nx = x + dx[i];
                    <span class="hljs-keyword">int</span> ny = y + dy[i];
                    <span class="hljs-comment">// use new state so we don't mess up current state</span>
                    <span class="hljs-keyword">int</span> nState = state;
                    <span class="hljs-comment">// out of bounds or reached wall</span>
                    <span class="hljs-keyword">if</span> (!inBounds(nx, ny) || grid[nx][ny] == <span class="hljs-string">'#'</span>) {
                        <span class="hljs-keyword">continue</span>;
                    }
                    <span class="hljs-comment">// found key</span>
                    <span class="hljs-comment">// use OR to add key to our current state because if we already had the key the</span>
                    <span class="hljs-comment">// digit would still be 1/true</span>
                    <span class="hljs-keyword">if</span> (<span class="hljs-string">'a'</span> &lt;= grid[nx][ny] &amp;&amp; grid[nx][ny] &lt;= <span class="hljs-string">'f'</span>) {
                        <span class="hljs-comment">// bit mask our found key</span>
                        nState = state | (<span class="hljs-number">1</span> &lt;&lt; (grid[nx][ny] - <span class="hljs-string">'a'</span>));
                    }
                    <span class="hljs-comment">// found lock</span>
                    <span class="hljs-comment">// use &amp; to see if we have the key</span>
                    <span class="hljs-comment">// 0 means that the digit we are looking at is 0</span>
                    <span class="hljs-comment">// need a 1 at the digit spot which means there is a key there</span>
                    <span class="hljs-keyword">if</span> ((<span class="hljs-string">'A'</span> &gt; grid[nx][ny]
                                    || grid[nx][ny] &gt; <span class="hljs-string">'F'</span>
                                    || ((nState &amp; (<span class="hljs-number">1</span> &lt;&lt; (grid[nx][ny] - <span class="hljs-string">'A'</span>))) != <span class="hljs-number">0</span>))
                            &amp;&amp; !visited[nx][ny][nState]) {
                        q.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] {nx, ny, nState});
                        visited[nx][ny][nState] = <span class="hljs-keyword">true</span>;
                    }
                }
            }
            steps++;
        }
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">inBounds</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n;
    }
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/BaffinLee/leetcode-javascript" target="_blank"><img src="https://baffinlee.com/leetcode-javascript/static/img/github.png" alt="github"/></a></footer></body></html>