<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Smallest Missing Genetic Value in Each Subtree - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>2003. Smallest Missing Genetic Value in Each Subtree</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/dynamic-programming">Dynamic Programming</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/tree">Tree</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/depth-first-search">Depth-First Search</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/union-find">Union Find</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>There is a <strong>family tree</strong> rooted at <code>0</code> consisting of <code>n</code> nodes numbered <code>0</code> to <code>n - 1</code>. You are given a <strong>0-indexed</strong> integer array <code>parents</code>, where <code>parents[i]</code> is the parent for node <code>i</code>. Since node <code>0</code> is the <strong>root</strong>, <code>parents[0] == -1</code>.</p>
<p>There are <code>105</code> genetic values, each represented by an integer in the <strong>inclusive</strong> range <code>[1, 105]</code>. You are given a <strong>0-indexed</strong> integer array <code>nums</code>, where <code>nums[i]</code> is a **distinct **genetic value for node <code>i</code>.</p>
<p>Return **an array *<em><code>ans</code></em>* of length <strong><code>n</code></strong> where <strong><code>ans[i]</code></strong> is** **the *<em>smallest</em>* genetic value that is <strong>missing</strong> from the subtree rooted at node** <code>i</code>.</p>
<p>The <strong>subtree</strong> rooted at a node <code>x</code> contains node <code>x</code> and all of its <strong>descendant</strong> nodes.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/08/23/case-1.png" alt="" /></p>
<pre><code class="hljs">Input: parents = [<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>], nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
Output: [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]
Explanation: The answer <span class="hljs-keyword">for</span> each subtree <span class="hljs-keyword">is</span> calculated as follows:
- <span class="hljs-number">0</span>: The subtree contains nodes [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] with values [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]. <span class="hljs-number">5</span> <span class="hljs-keyword">is</span> the smallest missing value.
- <span class="hljs-number">1</span>: The subtree contains only node <span class="hljs-number">1</span> with value <span class="hljs-number">2.</span> <span class="hljs-number">1</span> <span class="hljs-keyword">is</span> the smallest missing value.
- <span class="hljs-number">2</span>: The subtree contains nodes [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] with values [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]. <span class="hljs-number">1</span> <span class="hljs-keyword">is</span> the smallest missing value.
- <span class="hljs-number">3</span>: The subtree contains only node <span class="hljs-number">3</span> with value <span class="hljs-number">4.</span> <span class="hljs-number">1</span> <span class="hljs-keyword">is</span> the smallest missing value.
</code></pre>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/08/23/case-2.png" alt="" /></p>
<pre><code class="hljs">Input: parents = [<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>], nums = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]
Output: [<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
Explanation: The answer <span class="hljs-keyword">for</span> each subtree <span class="hljs-keyword">is</span> calculated as follows:
- <span class="hljs-number">0</span>: The subtree contains nodes [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] with values [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]. <span class="hljs-number">7</span> <span class="hljs-keyword">is</span> the smallest missing value.
- <span class="hljs-number">1</span>: The subtree contains nodes [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] with values [<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]. <span class="hljs-number">1</span> <span class="hljs-keyword">is</span> the smallest missing value.
- <span class="hljs-number">2</span>: The subtree contains only node <span class="hljs-number">2</span> with value <span class="hljs-number">6.</span> <span class="hljs-number">1</span> <span class="hljs-keyword">is</span> the smallest missing value.
- <span class="hljs-number">3</span>: The subtree contains nodes [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] with values [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]. <span class="hljs-number">4</span> <span class="hljs-keyword">is</span> the smallest missing value.
- <span class="hljs-number">4</span>: The subtree contains only node <span class="hljs-number">4</span> with value <span class="hljs-number">1.</span> <span class="hljs-number">2</span> <span class="hljs-keyword">is</span> the smallest missing value.
- <span class="hljs-number">5</span>: The subtree contains only node <span class="hljs-number">5</span> with value <span class="hljs-number">3.</span> <span class="hljs-number">1</span> <span class="hljs-keyword">is</span> the smallest missing value.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code class="hljs">Input: parents = [<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>], nums = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]
Output: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]
Explanation: The value <span class="hljs-number">1</span> <span class="hljs-keyword">is</span> missing <span class="hljs-keyword">from</span> all the subtrees.
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>n == parents.length == nums.length</code></p></li>
<li><p><code>2 &lt;= n &lt;= 105</code></p></li>
<li><p><code>0 &lt;= parents[i] &lt;= n - 1</code> for <code>i != 0</code></p></li>
<li><p><code>parents[0] == -1</code></p></li>
<li><p><code>parents</code> represents a valid tree.</p></li>
<li><p><code>1 &lt;= nums[i] &lt;= 105</code></p></li>
<li><p>Each <code>nums[i]</code> is distinct.</p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] smallestMissingValueSubtree(<span class="hljs-keyword">int</span>[] parents, <span class="hljs-keyword">int</span>[] nums) {
        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[parents.length];
        Node[] all = <span class="hljs-keyword">new</span> Node[parents.length];
        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
            all[i] = <span class="hljs-keyword">new</span> Node(i, nums[i]);
            max = Math.max(max, nums[i]);
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; parents.length; i++) {
            all[parents[i]].nodes.add(all[i]);
        }
        solve(all[<span class="hljs-number">0</span>], ans, <span class="hljs-keyword">new</span> UF(++max, nums));
        <span class="hljs-keyword">return</span> ans;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(Node root, <span class="hljs-keyword">int</span>[] ans, UF uf)</span> </span>{
        <span class="hljs-keyword">int</span> max = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (Node child : root.nodes) {
            solve(child, ans, uf);
            uf.union(root.val, child.val);
            max = Math.max(ans[child.idx], max);
        }
        <span class="hljs-keyword">while</span> (max &lt;= ans.length &amp;&amp; uf.isConnected(max, root.val)) {
            ++max;
        }
        ans[root.idx] = max;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>{
        <span class="hljs-keyword">int</span> idx;
        <span class="hljs-keyword">int</span> val;
        List&lt;Node&gt; nodes;

        Node(<span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> val) {
            <span class="hljs-keyword">this</span>.idx = idx;
            <span class="hljs-keyword">this</span>.val = val;
            nodes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span> </span>{
        <span class="hljs-keyword">int</span>[] rank;
        <span class="hljs-keyword">int</span>[] parent;

        UF(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[] nums) {
            rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
            parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m : nums) {
                parent[m] = m;
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
            <span class="hljs-keyword">if</span> (x == parent[x]) {
                <span class="hljs-keyword">return</span> x;
            }
            parent[x] = find(parent[x]);
            <span class="hljs-keyword">return</span> parent[x];
        }

        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
            x = find(x);
            y = find(y);
            <span class="hljs-keyword">if</span> (rank[x] &gt; rank[y]) {
                parent[y] = x;
            } <span class="hljs-keyword">else</span> {
                parent[x] = y;
                <span class="hljs-keyword">if</span> (rank[x] == rank[y]) {
                    rank[y]++;
                }
            }
        }

        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
            <span class="hljs-keyword">return</span> find(x) == find(y);
        }
    }
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>