<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>GCD Sort of an Array - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>1998. GCD Sort of an Array</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/array">Array</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/math">Math</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/union-find">Union Find</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/sorting">Sorting</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/rank-transform-of-a-matrix.html">Rank Transform of a Matrix</a></li></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>You are given an integer array <code>nums</code>, and you can perform the following operation <strong>any</strong> number of times on <code>nums</code>:</p>
<ul>
<li>Swap the positions of two elements <code>nums[i]</code> and <code>nums[j]</code> if <code>gcd(nums[i], nums[j]) &gt; 1</code> where <code>gcd(nums[i], nums[j])</code> is the <strong>greatest common divisor</strong> of <code>nums[i]</code> and <code>nums[j]</code>.</li>
</ul>
<p>Return <code>true</code> **if it is possible to sort *<em><code>nums</code></em>* in <strong>non-decreasing</strong> order using the above swap method, or <strong><code>false</code></strong> otherwise.**</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<pre><code class="hljs">Input: nums = [<span class="hljs-number">7</span>,<span class="hljs-number">21</span>,<span class="hljs-number">3</span>]
Output: <span class="hljs-literal">true</span>
Explanation: We can sort [<span class="hljs-number">7</span>,<span class="hljs-number">21</span>,<span class="hljs-number">3</span>] by performing the following operations:
- Swap <span class="hljs-number">7</span> <span class="hljs-keyword">and</span> <span class="hljs-number">21</span> because gcd(<span class="hljs-number">7</span>,<span class="hljs-number">21</span>) = <span class="hljs-number">7.</span> nums = [<span class="hljs-number">21</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>]
- Swap <span class="hljs-number">21</span> <span class="hljs-keyword">and</span> <span class="hljs-number">3</span> because gcd(<span class="hljs-number">21</span>,<span class="hljs-number">3</span>) = <span class="hljs-number">3.</span> nums = [<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">21</span>]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code class="hljs">Input: nums = [5,2,6,2]
Output: false
Explanation: It is impossible to sort the<span class="hljs-built_in"> array </span>because 5 cannot be swapped with any other element.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code class="hljs">Input: nums = [<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>]
Output: <span class="hljs-literal">true</span>
We can sort [<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>] by performing the following operations:
- Swap <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> <span class="hljs-number">15</span> because gcd(<span class="hljs-number">10</span>,<span class="hljs-number">15</span>) = <span class="hljs-number">5.</span> nums = [<span class="hljs-number">15</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">10</span>]
- Swap <span class="hljs-number">15</span> <span class="hljs-keyword">and</span> <span class="hljs-number">3</span> because gcd(<span class="hljs-number">15</span>,<span class="hljs-number">3</span>) = <span class="hljs-number">3.</span> nums = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">15</span>,<span class="hljs-number">10</span>]
- Swap <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> <span class="hljs-number">15</span> because gcd(<span class="hljs-number">10</span>,<span class="hljs-number">15</span>) = <span class="hljs-number">5.</span> nums = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>]
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>1 &lt;= nums.length &lt;= 3 * 104</code></p></li>
<li><p><code>2 &lt;= nums[i] &lt;= 105</code></p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">gcdSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{
        <span class="hljs-keyword">int</span>[] sorted = nums.clone();
        Arrays.sort(sorted);
        <span class="hljs-keyword">int</span> len = nums.length;
        <span class="hljs-keyword">int</span> max = sorted[len - <span class="hljs-number">1</span>];
        <span class="hljs-comment">// grouping tree child(index)-&gt;parent(value), index==value is root</span>
        <span class="hljs-keyword">int</span>[] nodes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j : nums) {
            nodes[j] = -<span class="hljs-number">1</span>;
        }
        <span class="hljs-comment">// value: &lt;=0 not sieved, &lt;0 leaf node, 0 or 1 not in nums, &gt;1 grouped</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = <span class="hljs-number">2</span>; p &lt;= max / <span class="hljs-number">2</span>; p++) {
            <span class="hljs-keyword">if</span> (nodes[p] &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-comment">// sieved so not a prime number.</span>
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-comment">// p is now a prime number, set self as root.</span>
            nodes[p] = p;
            <span class="hljs-keyword">int</span> group = p;
            <span class="hljs-keyword">int</span> num = p + p;
            <span class="hljs-keyword">while</span> (num &lt;= max) {
                <span class="hljs-keyword">int</span> existing = nodes[num];
                <span class="hljs-keyword">if</span> (existing &lt; <span class="hljs-number">0</span>) {
                    <span class="hljs-comment">// 1st hit, set group</span>
                    nodes[num] = group;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (existing &lt;= <span class="hljs-number">1</span>) {
                    <span class="hljs-comment">// value doesn't exist in nums</span>
                    nodes[num] = <span class="hljs-number">1</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((existing = root(nodes, existing)) &lt; group) {
                    nodes[group] = existing;
                    group = existing;
                } <span class="hljs-keyword">else</span> {
                    nodes[existing] = group;
                }
                num += p;
            }
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
            <span class="hljs-keyword">if</span> (root(nodes, nums[i]) != root(nodes, (sorted[i]))) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">root</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] nodes, <span class="hljs-keyword">int</span> num)</span> </span>{
        <span class="hljs-keyword">int</span> group;
        <span class="hljs-keyword">while</span> ((group = nodes[num]) &gt; <span class="hljs-number">0</span> &amp;&amp; group != num) {
            num = group;
        }
        <span class="hljs-keyword">return</span> num;
    }
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>