<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Erect the Fence - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>587. Erect the Fence</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/array">Array</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/math">Math</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/geometry">Geometry</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/erect-the-fence-ii.html">Erect the Fence II</a></li></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>You are given an array <code>trees</code> where <code>trees[i] = [xi, yi]</code> represents the location of a tree in the garden.</p>
<p>You are asked to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if <strong>all the trees are enclosed</strong>.</p>
<p>Return <strong>the coordinates of trees that are exactly located on the fence perimeter</strong>.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/24/erect2-plane.jpg" alt="" /></p>
<pre><code class="hljs">Input: points = [[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]]
Output: [[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]]
</code></pre>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/24/erect1-plane.jpg" alt="" /></p>
<pre><code class="hljs">Input: points = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]]
Output: [[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]]
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>1 &lt;= points.length &lt;= 3000</code></p></li>
<li><p><code>points[i].length == 2</code></p></li>
<li><p><code>0 &lt;= xi, yi &lt;= 100</code></p></li>
<li><p>All the given points are <strong>unique</strong>.</p></li>
</ul>
<h2 id="solution-java">Solution (Java)</h2>
<pre><code class="hljs lang-java"><span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">100</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] outerTrees(<span class="hljs-keyword">int</span>[][] trees) {
        <span class="hljs-keyword">int</span> n = trees.length;
        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) {
            <span class="hljs-keyword">return</span> trees;
        }
        radixSort2D(trees);
        <span class="hljs-keyword">int</span>[][] st = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n * <span class="hljs-number">2</span>][];
        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] t : trees) {
            <span class="hljs-keyword">while</span> (idx &gt; <span class="hljs-number">1</span> &amp;&amp; polarOrder(st[idx - <span class="hljs-number">2</span>], st[idx - <span class="hljs-number">1</span>], t) &lt; <span class="hljs-number">0</span>) {
                idx--;
            }
            st[idx++] = t;
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            <span class="hljs-keyword">while</span> (idx &gt; <span class="hljs-number">1</span> &amp;&amp; polarOrder(st[idx - <span class="hljs-number">2</span>], st[idx - <span class="hljs-number">1</span>], trees[i]) &lt; <span class="hljs-number">0</span>) {
                idx--;
            }
            st[idx++] = trees[i];
        }
        <span class="hljs-keyword">return</span> Arrays.stream(st, <span class="hljs-number">0</span>, idx).distinct().toArray(<span class="hljs-keyword">int</span>[][]::<span class="hljs-keyword">new</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort2D</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] trees)</span> </span>{
        <span class="hljs-keyword">int</span>[][] aux = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[trees.length][];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>; p &gt;= <span class="hljs-number">0</span>; p--) {
            <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAX + <span class="hljs-number">2</span>];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] t : trees) {
                count[t[p] + <span class="hljs-number">1</span>]++;
            }
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt;= MAX; c++) {
                count[c + <span class="hljs-number">1</span>] += count[c];
            }
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] t : trees) {
                aux[count[t[p]]++] = t;
            }
            System.arraycopy(aux, <span class="hljs-number">0</span>, trees, <span class="hljs-number">0</span>, trees.length);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">polarOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] p, <span class="hljs-keyword">int</span>[] q, <span class="hljs-keyword">int</span>[] r)</span> </span>{
        <span class="hljs-keyword">return</span> (q[<span class="hljs-number">0</span>] - p[<span class="hljs-number">0</span>]) * (r[<span class="hljs-number">1</span>] - q[<span class="hljs-number">1</span>]) - (q[<span class="hljs-number">1</span>] - p[<span class="hljs-number">1</span>]) * (r[<span class="hljs-number">0</span>] - q[<span class="hljs-number">0</span>]);
    }
}
</code></pre>
<h2 id="solution-javascript">Solution (Javascript)</h2>
<pre><code class="hljs lang-javascript"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param <span class="hljs-type">{number[][]}</span> <span class="hljs-variable">trees</span></span>
 * <span class="hljs-doctag">@return <span class="hljs-type">{number[][]}</span></span>
 */</span>
<span class="hljs-keyword">var</span> outerTrees = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">trees</span>) </span>{
    trees.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> (a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]) || (a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]));

    <span class="hljs-keyword">let</span> upper = [];
    <span class="hljs-keyword">let</span> lower = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> t <span class="hljs-keyword">of</span> trees){
        <span class="hljs-keyword">while</span> (upper.length &gt;= <span class="hljs-number">2</span> &amp;&amp; ccw(upper[upper.length - <span class="hljs-number">2</span>], upper[upper.length<span class="hljs-number">-1</span>], t) &lt; <span class="hljs-number">0</span>){
            upper.pop();
        }
        <span class="hljs-keyword">while</span> (lower.length &gt;= <span class="hljs-number">2</span> &amp;&amp; ccw(lower[lower.length <span class="hljs-number">-2</span>], lower[lower.length<span class="hljs-number">-1</span>], t) &gt; <span class="hljs-number">0</span>){
            lower.pop();
        }
        upper.push(t);
        lower.push(t);
    }
    <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>([...upper,...lower])];
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ccw</span>(<span class="hljs-params">p1, p2, p3</span>)</span>{
    <span class="hljs-keyword">return</span> (p3[<span class="hljs-number">1</span>] - p2[<span class="hljs-number">1</span>])*(p2[<span class="hljs-number">0</span>]-p1[<span class="hljs-number">0</span>]) - (p2[<span class="hljs-number">1</span>]-p1[<span class="hljs-number">1</span>])*(p3[<span class="hljs-number">0</span>]-p2[<span class="hljs-number">0</span>]);
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>