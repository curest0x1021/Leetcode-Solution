<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>LFU Cache - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>460. LFU Cache</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/hash-table">Hash Table</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/linked-list">Linked List</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/design">Design</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/doubly-linked-list">Doubly-Linked List</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/lru-cache.html">LRU Cache</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/design-in-memory-file-system.html">Design In-Memory File System</a></li></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>Design and implement a data structure for a Least Frequently Used (LFU) cache.</p>
<p>Implement the <code>LFUCache</code> class:</p>
<ul>
<li><p><code>LFUCache(int capacity)</code> Initializes the object with the <code>capacity</code> of the data structure.</p></li>
<li><p><code>int get(int key)</code> Gets the value of the <code>key</code> if the <code>key</code> exists in the cache. Otherwise, returns <code>-1</code>.</p></li>
<li><p><code>void put(int key, int value)</code> Update the value of the <code>key</code> if present, or inserts the <code>key</code> if not already present. When the cache reaches its <code>capacity</code>, it should invalidate and remove the <strong>least frequently used</strong> key before inserting a new item. For this problem, when there is a <strong>tie</strong> (i.e., two or more keys with the same frequency), the <strong>least recently used</strong> <code>key</code> would be invalidated.</p></li>
</ul>
<p>To determine the least frequently used key, a <strong>use counter</strong> is maintained for each key in the cache. The key with the smallest <strong>use counter</strong> is the least frequently used key.</p>
<p>When a key is first inserted into the cache, its <strong>use counter</strong> is set to <code>1</code> (due to the <code>put</code> operation). The <strong>use counter</strong> for a key in the cache is incremented either a <code>get</code> or <code>put</code> operation is called on it.</p>
<p>The functions&nbsp;get&nbsp;and&nbsp;put&nbsp;must each run in <code>O(1)</code> average time complexity.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<pre><code class="hljs">Input
[<span class="hljs-string">"LFUCache"</span>, <span class="hljs-string">"put"</span>, <span class="hljs-string">"put"</span>, <span class="hljs-string">"get"</span>, <span class="hljs-string">"put"</span>, <span class="hljs-string">"get"</span>, <span class="hljs-string">"get"</span>, <span class="hljs-string">"put"</span>, <span class="hljs-string">"get"</span>, <span class="hljs-string">"get"</span>, <span class="hljs-string">"get"</span>]
[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]
Output
[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]

Explanation
<span class="hljs-comment">// cnt(x) = the use counter for key x</span>
<span class="hljs-comment">// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)</span>
LFUCache lfu = new LFUCache(<span class="hljs-number">2</span>);
lfu.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);   <span class="hljs-comment">// cache=[1,_], cnt(1)=1</span>
lfu.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);   <span class="hljs-comment">// cache=[2,1], cnt(2)=1, cnt(1)=1</span>
lfu.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);      <span class="hljs-comment">// return 1</span>
                 <span class="hljs-comment">// cache=[1,2], cnt(2)=1, cnt(1)=2</span>
lfu.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);   <span class="hljs-comment">// 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.</span>
&amp;nbsp;                <span class="hljs-comment">// cache=[3,1], cnt(3)=1, cnt(1)=2</span>
lfu.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);      <span class="hljs-comment">// return -1 (not found)</span>
lfu.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);      <span class="hljs-comment">// return 3</span>
                 <span class="hljs-comment">// cache=[3,1], cnt(3)=2, cnt(1)=2</span>
lfu.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);   <span class="hljs-comment">// Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.</span>
                 <span class="hljs-comment">// cache=[4,3], cnt(4)=1, cnt(3)=2</span>
lfu.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);      <span class="hljs-comment">// return -1 (not found)</span>
lfu.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);      <span class="hljs-comment">// return 3</span>
                 <span class="hljs-comment">// cache=[3,4], cnt(4)=1, cnt(3)=3</span>
lfu.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);      <span class="hljs-comment">// return 4</span>
                 <span class="hljs-comment">// cache=[4,3], cnt(4)=2, cnt(3)=3</span>
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>0 &lt;= capacity&amp;nbsp;&lt;= 104</code></p></li>
<li><p><code>0 &lt;= key &lt;= 105</code></p></li>
<li><p><code>0 &lt;= value &lt;= 109</code></p></li>
<li><p>At most <code>2 * 105</code>&nbsp;calls will be made to <code>get</code> and <code>put</code>.</p></li>
</ul>
<h2 id="solution-java">Solution (Java)</h2>
<pre><code class="hljs lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LFUCache</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>{
        Node prev;
        Node next;
        <span class="hljs-keyword">int</span> key = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> val;
        <span class="hljs-keyword">int</span> freq;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Node&gt; endOfBlock;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Node&gt; map;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> capacity;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node linkedList;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LFUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>{
        endOfBlock = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        <span class="hljs-keyword">this</span>.capacity = capacity;
        linkedList = <span class="hljs-keyword">new</span> Node();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>{
        <span class="hljs-keyword">if</span> (map.containsKey(key)) {
            Node newEndNode = map.get(key);
            Node endNode;
            Node currEndNode = endOfBlock.get(newEndNode.freq);
            <span class="hljs-keyword">if</span> (currEndNode == newEndNode) {
                findNewEndOfBlock(newEndNode);
                <span class="hljs-keyword">if</span> (currEndNode.next == <span class="hljs-keyword">null</span> || currEndNode.next.freq &gt; newEndNode.freq + <span class="hljs-number">1</span>) {
                    newEndNode.freq++;
                    endOfBlock.put(newEndNode.freq, newEndNode);
                    <span class="hljs-keyword">return</span> newEndNode.val;
                }
            }
            <span class="hljs-keyword">if</span> (newEndNode.next != <span class="hljs-keyword">null</span>) {
                newEndNode.next.prev = newEndNode.prev;
            }
            newEndNode.prev.next = newEndNode.next;
            newEndNode.freq++;
            <span class="hljs-keyword">if</span> (currEndNode.next == <span class="hljs-keyword">null</span> || currEndNode.next.freq &gt; newEndNode.freq) {
                endNode = currEndNode;
            } <span class="hljs-keyword">else</span> {
                endNode = endOfBlock.get(newEndNode.freq);
            }
            endOfBlock.put(newEndNode.freq, newEndNode);
            <span class="hljs-keyword">if</span> (endNode.next != <span class="hljs-keyword">null</span>) {
                endNode.next.prev = newEndNode;
            }
            newEndNode.next = endNode.next;
            endNode.next = newEndNode;
            newEndNode.prev = endNode;
            <span class="hljs-keyword">return</span> newEndNode.val;
        }
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>{
        Node endNode;
        Node newEndNode;
        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">if</span> (map.containsKey(key)) {
            map.get(key).val = value;
            get(key);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (map.size() == capacity) {
                Node toDelete = linkedList.next;
                map.remove(toDelete.key);
                <span class="hljs-keyword">if</span> (toDelete.next != <span class="hljs-keyword">null</span>) {
                    toDelete.next.prev = linkedList;
                }
                linkedList.next = toDelete.next;
                <span class="hljs-keyword">if</span> (endOfBlock.get(toDelete.freq) == toDelete) {
                    endOfBlock.remove(toDelete.freq);
                }
            }
            newEndNode = <span class="hljs-keyword">new</span> Node();
            newEndNode.key = key;
            newEndNode.val = value;
            newEndNode.freq = <span class="hljs-number">1</span>;
            map.put(key, newEndNode);
            endNode = endOfBlock.getOrDefault(<span class="hljs-number">1</span>, linkedList);
            endOfBlock.put(<span class="hljs-number">1</span>, newEndNode);
            <span class="hljs-keyword">if</span> (endNode.next != <span class="hljs-keyword">null</span>) {
                endNode.next.prev = newEndNode;
            }
            newEndNode.next = endNode.next;
            endNode.next = newEndNode;
            newEndNode.prev = endNode;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findNewEndOfBlock</span><span class="hljs-params">(Node node)</span> </span>{
        Node prev = node.prev;
        <span class="hljs-keyword">if</span> (prev.freq == node.freq) {
            endOfBlock.put(node.freq, prev);
        } <span class="hljs-keyword">else</span> {
            endOfBlock.remove(node.freq);
        }
    }
}

<span class="hljs-comment">/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache obj = new LFUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */</span>
</code></pre>
<h2 id="solution-javascript">Solution (Javascript)</h2>
<pre><code class="hljs lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>{
  <span class="hljs-keyword">constructor</span>(key=null, value=null) {
    <span class="hljs-keyword">this</span>.key = key;
    <span class="hljs-keyword">this</span>.val = value;
    <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">this</span>.prev = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.freq = <span class="hljs-number">1</span>;
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoublyLinkedList</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">new</span> Node();
    <span class="hljs-keyword">this</span>.tail = <span class="hljs-keyword">new</span> Node();
    <span class="hljs-keyword">this</span>.head.next = <span class="hljs-keyword">this</span>.tail;
    <span class="hljs-keyword">this</span>.tail.prev = <span class="hljs-keyword">this</span>.head;
  }

  insertHead(node) {
    node.prev = <span class="hljs-keyword">this</span>.head;
    node.next = <span class="hljs-keyword">this</span>.head.next;
    <span class="hljs-keyword">this</span>.head.next.prev = node;
    <span class="hljs-keyword">this</span>.head.next = node;
  }

  removeNode(node) {
    <span class="hljs-keyword">const</span> prev = node.prev;
    <span class="hljs-keyword">const</span> next = node.next;
    prev.next = next;
    next.prev = prev;
  }

  removeTail() {
    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">this</span>.tail.prev;
    <span class="hljs-keyword">this</span>.removeNode(node);
    <span class="hljs-keyword">return</span> node.key;
  }

  isEmpty() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.head.next.val == <span class="hljs-literal">null</span>;
  }
}

<span class="hljs-keyword">const</span> LFUCache = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">capacity</span>) </span>{
  <span class="hljs-keyword">this</span>.capacity = capacity;
  <span class="hljs-keyword">this</span>.currentSize = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.leastFreq = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.keyNodeMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">this</span>.freqNodeMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
};

LFUCache.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
  <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">this</span>.keyNodeMap.get(key);
  <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">this</span>.updateNode(node);
  <span class="hljs-keyword">return</span> node.val;
};

LFUCache.prototype.put = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.capacity == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">this</span>.keyNodeMap.get(key);
  <span class="hljs-keyword">if</span> (!node) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentSize == <span class="hljs-keyword">this</span>.capacity) {
      <span class="hljs-comment">// Evict the least recently used key happens here!</span>
      <span class="hljs-keyword">const</span> tailKey = <span class="hljs-keyword">this</span>.freqNodeMap.get(<span class="hljs-keyword">this</span>.leastFreq).removeTail();
      <span class="hljs-keyword">this</span>.keyNodeMap.delete(tailKey);
      <span class="hljs-keyword">this</span>.currentSize -= <span class="hljs-number">1</span>;
    }
    <span class="hljs-comment">// Since it's a new node, we need to increase current size.</span>
    <span class="hljs-keyword">this</span>.currentSize += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> Node(key, value);
    <span class="hljs-keyword">this</span>.insertNode(newNode);
    <span class="hljs-keyword">this</span>.keyNodeMap.set(key, newNode);
    <span class="hljs-comment">// We are sure it's gonna be 1, lol.</span>
    <span class="hljs-keyword">this</span>.leastFreq = <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">else</span> {
    node.val = value;
    <span class="hljs-keyword">this</span>.updateNode(node);
  }
};

LFUCache.prototype.insertNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.freqNodeMap.get(node.freq) == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">this</span>.freqNodeMap.set(node.freq, <span class="hljs-keyword">new</span> DoublyLinkedList());
  }
  <span class="hljs-keyword">this</span>.freqNodeMap.get(node.freq).insertHead(node);
}

<span class="hljs-comment">/**
* 1) First it removes the node from current DLL,
* 2) If its frequency is leastFreq and its the only node in the DLL, increase the leastFreq,
* 3) Increase current node's frequency and insert it to the new DLL.
* Note that after step 1), the DLL could be an empty DLL, instead of clearing the frequency from the map,
* and deleting the empty DLL, we keep it empty, and no need to init a new DLL for the next key with this
* frequency, and potentially save some work, not bad!
*/</span>
LFUCache.prototype.updateNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">this</span>.freqNodeMap.get(node.freq).removeNode(node);
  <span class="hljs-keyword">if</span> (node.freq == <span class="hljs-keyword">this</span>.leastFreq &amp;&amp; <span class="hljs-keyword">this</span>.freqNodeMap.get(node.freq).isEmpty()) {
    <span class="hljs-keyword">this</span>.leastFreq += <span class="hljs-number">1</span>;
  }
  node.freq += <span class="hljs-number">1</span>;
  <span class="hljs-keyword">this</span>.insertNode(node);
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>