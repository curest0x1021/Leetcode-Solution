<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Minimum Number of Flips to Convert Binary Matrix to Zero Matrix - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/array">Array</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/bit-manipulation">Bit Manipulation</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/breadth-first-search">Breadth-First Search</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/matrix">Matrix</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/minimum-operations-to-remove-adjacent-ones-in-matrix.html">Minimum Operations to Remove Adjacent Ones in Matrix</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/remove-all-ones-with-row-and-column-flips.html">Remove All Ones With Row and Column Flips</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/problem/remove-all-ones-with-row-and-column-flips-ii.html">Remove All Ones With Row and Column Flips II</a></li></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>Given a <code>m x n</code> binary matrix <code>mat</code>. In one step, you can choose one cell and flip it and all the four neighbors of it if they exist (Flip is changing <code>1</code> to <code>0</code> and <code>0</code> to <code>1</code>). A pair of cells are called neighbors if they share one edge.</p>
<p>Return the <strong>minimum number of steps</strong> required to convert <code>mat</code> to a zero matrix or <code>-1</code> if you cannot.</p>
<p>A <strong>binary matrix</strong> is a matrix with all cells equal to <code>0</code> or <code>1</code> only.</p>
<p>A <strong>zero matrix</strong> is a matrix with all cells equal to <code>0</code>.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/11/28/matrix.png" alt="" /></p>
<pre><code class="hljs">Input: mat = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]
Output: <span class="hljs-number">3</span>
Explanation: One possible solution <span class="hljs-keyword">is</span> to flip (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) then (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> finally (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) as shown.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code class="hljs">Inpu<span class="hljs-variable">t:</span> <span class="hljs-keyword">mat</span> = [[<span class="hljs-number">0</span>]]
Outpu<span class="hljs-variable">t:</span> <span class="hljs-number">0</span>
Explanation: Given matrix <span class="hljs-keyword">is</span> <span class="hljs-keyword">a</span> zero matrix. We <span class="hljs-keyword">do</span> not need <span class="hljs-keyword">to</span> <span class="hljs-keyword">change</span> it.
</code></pre>
<p><strong>Example 3:</strong></p>
<pre><code class="hljs">Input: mat = [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]
Output: <span class="hljs-number">-1</span>
Explanation: Given matrix cannot be a zero matrix.
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>m == mat.length</code></p></li>
<li><p><code>n == mat[i].length</code></p></li>
<li><p><code>1 &lt;= m, n &lt;= 3</code></p></li>
<li><p><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-java"><span class="hljs-keyword">import</span> java.util.ArrayDeque;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Queue;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">private</span> Set&lt;Integer&gt; visited;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span> </span>{
        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; r &amp;&amp; y &lt; c;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title">next</span><span class="hljs-params">(Integer n, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span> </span>{
        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">int</span>[] dx = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>};
        <span class="hljs-keyword">int</span>[] dy = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>};
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; c; j++) {
                Integer newMask = n;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; dx.length; k++) {
                    <span class="hljs-keyword">int</span> nx = i + dx[k];
                    <span class="hljs-keyword">int</span> ny = j + dy[k];
                    <span class="hljs-keyword">if</span> (isValid(nx, ny, r, c)) {
                        newMask = newMask ^ (<span class="hljs-number">1</span> &lt;&lt; (nx * <span class="hljs-number">3</span> + ny));
                    }
                }
                <span class="hljs-keyword">if</span> (visited.add(newMask)) {
                    ans.add(newMask);
                }
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minFlips</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] mat)</span> </span>{
        <span class="hljs-keyword">int</span> mask = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> r = mat.length;
        <span class="hljs-keyword">int</span> c = mat[<span class="hljs-number">0</span>].length;
        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">1</span> &amp;&amp; c == <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; c; j++) {
                mask |= (mat[i][j] &lt;&lt; (i * <span class="hljs-number">3</span> + j));
            }
        }
        <span class="hljs-keyword">if</span> (mask == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        visited = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
        Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;
        q.add(mask);
        visited.add(mask);
        <span class="hljs-keyword">while</span> (!q.isEmpty()) {
            <span class="hljs-keyword">int</span> qSize = q.size();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; qSize; i++) {
                Integer currMask = q.poll();
                List&lt;Integer&gt; nextStates = next(currMask, r, c);
                <span class="hljs-keyword">for</span> (Integer nextState : nextStates) {
                    <span class="hljs-keyword">if</span> (nextState == <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">return</span> count;
                    }
                    q.add(nextState);
                }
            }
            count++;
        }
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>