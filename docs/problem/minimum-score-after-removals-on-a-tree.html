<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Minimum Score After Removals on a Tree - LeetCode javascript solutions</title><link rel="shortcut icon" href="https://curest0x1021.github.io/Leetcode-Solution/static/img/favicon.png" type="image/png"/><link rel="stylesheet" href="https://curest0x1021.github.io/Leetcode-Solution/static/css/app.css"/></head><body><header><h1>2322. Minimum Score After Removals on a Tree</h1><div class="row"><div class="name">Difficulty:</div><div class="value"><a href="https://curest0x1021.github.io/Leetcode-Solution/difficulty/hard" class="tag">Hard</a></div></div><div class="row"><div class="name">Related Topics:</div><div class="value"><ul class="clearfix"><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/array">Array</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/bit-manipulation">Bit Manipulation</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/tree">Tree</a></li><li><a href="https://curest0x1021.github.io/Leetcode-Solution/tag/depth-first-search">Depth-First Search</a></li></ul></div></div><div class="row"><div class="name">Similar Questions:</div><div class="value"><ul class="clearfix"></ul></div></div></header><main><article class="markdown-body"><h2 id="problem">Problem</h2>
<p>There is an undirected connected tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and <code>n - 1</code> edges.</p>
<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of length <code>n</code> where <code>nums[i]</code> represents the value of the <code>ith</code> node. You are also given a 2D integer array <code>edges</code> of length <code>n - 1</code> where <code>edges[i] = [ai, bi]</code> indicates that there is an edge between nodes <code>ai</code> and <code>bi</code> in the tree.</p>
<p>Remove two <strong>distinct</strong> edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:</p>
<ul>
<li><p>Get the XOR of all the values of the nodes for <strong>each</strong> of the three components respectively.</p></li>
<li><p>The <strong>difference</strong> between the <strong>largest</strong> XOR value and the <strong>smallest</strong> XOR value is the <strong>score</strong> of the pair.</p></li>


<li><p>For example, say the three components have the node values: <code>[4,5,7]</code>, <code>[1,9]</code>, and <code>[3,3,3]</code>. The three XOR values are <code>4 ^ 5 ^ 7 = **6**</code>, <code>1 ^ 9 = **8**</code>, and <code>3 ^ 3 ^ 3 = **3**</code>. The largest XOR value is <code>8</code> and the smallest XOR value is <code>3</code>. The score is then <code>8 - 3 = 5</code>.</p></li>
</ul>
<p>Return **the *<em>minimum</em>* score of any possible pair of edge removals on the given tree**.</p>
<p>&nbsp;
<strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/05/03/ex1drawio.png" alt="" /></p>
<pre><code class="hljs">Input: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">11</span>], edges = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]
Output: <span class="hljs-number">9</span>
Explanation: The diagram above shows a way to make a pair of removals.
- The <span class="hljs-number">1</span>st component has nodes [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] with values [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">11</span>]. Its XOR value <span class="hljs-keyword">is</span> <span class="hljs-number">5</span> ^ <span class="hljs-number">4</span> ^ <span class="hljs-number">11</span> = <span class="hljs-number">10.</span>
- The <span class="hljs-number">2</span>nd component has node [<span class="hljs-number">0</span>] with value [<span class="hljs-number">1</span>]. Its XOR value <span class="hljs-keyword">is</span> <span class="hljs-number">1</span> = <span class="hljs-number">1.</span>
- The <span class="hljs-number">3</span>rd component has node [<span class="hljs-number">2</span>] with value [<span class="hljs-number">5</span>]. Its XOR value <span class="hljs-keyword">is</span> <span class="hljs-number">5</span> = <span class="hljs-number">5.</span>
The score <span class="hljs-keyword">is</span> the difference between the largest <span class="hljs-keyword">and</span> smallest XOR value which <span class="hljs-keyword">is</span> <span class="hljs-number">10</span> - <span class="hljs-number">1</span> = <span class="hljs-number">9.</span>
It can be shown that no other pair of removals will obtain a smaller score than <span class="hljs-number">9.</span>
</code></pre>
<p><strong>Example 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/05/03/ex2drawio.png" alt="" /></p>
<pre><code class="hljs">Input: nums = [<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>], edges = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]]
Output: <span class="hljs-number">0</span>
Explanation: The diagram above shows a way to make a pair of removals.
- The <span class="hljs-number">1</span>st component has nodes [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] with values [<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]. Its XOR value <span class="hljs-keyword">is</span> <span class="hljs-number">4</span> ^ <span class="hljs-number">4</span> = <span class="hljs-number">0.</span>
- The <span class="hljs-number">2</span>nd component has nodes [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] with values [<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]. Its XOR value <span class="hljs-keyword">is</span> <span class="hljs-number">5</span> ^ <span class="hljs-number">5</span> = <span class="hljs-number">0.</span>
- The <span class="hljs-number">3</span>rd component has nodes [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>] with values [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]. Its XOR value <span class="hljs-keyword">is</span> <span class="hljs-number">2</span> ^ <span class="hljs-number">2</span> = <span class="hljs-number">0.</span>
The score <span class="hljs-keyword">is</span> the difference between the largest <span class="hljs-keyword">and</span> smallest XOR value which <span class="hljs-keyword">is</span> <span class="hljs-number">0</span> - <span class="hljs-number">0</span> = <span class="hljs-number">0.</span>
We cannot obtain a smaller score than <span class="hljs-number">0.</span>
</code></pre>
<p>&nbsp;
<strong>Constraints:</strong></p>
<ul>
<li><p><code>n == nums.length</code></p></li>
<li><p><code>3 &lt;= n &lt;= 1000</code></p></li>
<li><p><code>1 &lt;= nums[i] &lt;= 108</code></p></li>
<li><p><code>edges.length == n - 1</code></p></li>
<li><p><code>edges[i].length == 2</code></p></li>
<li><p><code>0 &lt;= ai, bi &lt; n</code></p></li>
<li><p><code>ai != bi</code></p></li>
<li><p><code>edges</code> represents a valid tree.</p></li>
</ul>
<h2 id="solution">Solution</h2>
<pre><code class="hljs lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ans = Integer.MAX_VALUE;

    <span class="hljs-comment">// function to travel 2nd time on the tree and find the second edge to be removed</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(
            <span class="hljs-keyword">int</span> src, ArrayList&lt;Integer&gt;[] graph, <span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> par, <span class="hljs-keyword">int</span> block, <span class="hljs-keyword">int</span> xor1, <span class="hljs-keyword">int</span> tot)</span> </span>{
        <span class="hljs-comment">// Setting the value for the current subtree's XOR value</span>
        <span class="hljs-keyword">int</span> myXOR = arr[src];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> nbr : graph[src]) {
            <span class="hljs-comment">// If the current nbr is niether the parent of this node nor the blocked node  , then</span>
            <span class="hljs-comment">// only we'll proceed</span>
            <span class="hljs-keyword">if</span> (nbr != par &amp;&amp; nbr != block) {
                <span class="hljs-keyword">int</span> nbrXOR = helper(nbr, graph, arr, src, block, xor1, tot);
                <span class="hljs-comment">// 'src &lt;----&gt; nbr' is the second edge to be removed</span>
                <span class="hljs-comment">// Getting the XOR value of the current neighbor</span>
                <span class="hljs-keyword">int</span> xor2 = nbrXOR;
                <span class="hljs-comment">// The XOR of the remaining component</span>
                <span class="hljs-keyword">int</span> xor3 = (tot ^ xor1) ^ xor2;
                <span class="hljs-comment">// Getting the minimum of the three values</span>
                <span class="hljs-keyword">int</span> max = Math.max(xor1, Math.max(xor2, xor3));
                <span class="hljs-comment">// Getting the maximum of the three value</span>
                <span class="hljs-keyword">int</span> min = Math.min(xor1, Math.min(xor2, xor3));
                ans = Math.min(ans, max - min);
                <span class="hljs-comment">// Including the neighbour subtree's XOR value in the XOR value of the subtree</span>
                <span class="hljs-comment">// rooted at src node</span>
                myXOR ^= nbrXOR;
            }
        }
        <span class="hljs-comment">// Returing the XOR value of the current subtree rooted at the src node</span>
        <span class="hljs-keyword">return</span> myXOR;
    }

    <span class="hljs-comment">// function to travel 1st time on the tree and find the first edge to be removed and</span>
    <span class="hljs-comment">// then block the node at which the edge ends to avoid selecting the same node again</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> src, ArrayList&lt;Integer&gt;[] graph, <span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> par, <span class="hljs-keyword">int</span> tot)</span> </span>{
        <span class="hljs-comment">// Setting the value for the current subtree's XOR value</span>
        <span class="hljs-keyword">int</span> myXOR = arr[src];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> nbr : graph[src]) {
            <span class="hljs-comment">// If the current nbr is not the parent of this node, then only we'll proceed</span>
            <span class="hljs-keyword">if</span> (nbr != par) {
                <span class="hljs-comment">// After selecting 'src &lt;----&gt; nbr' as the first edge, we block 'nbr' node and then</span>
                <span class="hljs-comment">// make a call to try all the second edges</span>
                <span class="hljs-keyword">int</span> nbrXOR = dfs(nbr, graph, arr, src, tot);
                <span class="hljs-comment">// Calling the helper to find the try all the second edges after blocking the</span>
                <span class="hljs-comment">// current node</span>
                helper(<span class="hljs-number">0</span>, graph, arr, -<span class="hljs-number">1</span>, nbr, nbrXOR, tot);
                <span class="hljs-comment">// Including the neighbour subtree's XOR value in the XOR value of the subtree</span>
                <span class="hljs-comment">// rooted at src node</span>
                myXOR ^= nbrXOR;
            }
        }
        <span class="hljs-comment">// Returing the XOR value of the current subtree rooted at the src node</span>
        <span class="hljs-keyword">return</span> myXOR;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span>[][] edges)</span> </span>{
        <span class="hljs-keyword">int</span> n = arr.length;
        ArrayList&lt;Integer&gt;[] graph = <span class="hljs-keyword">new</span> ArrayList[n];
        <span class="hljs-keyword">int</span> tot = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-comment">// Initializing the graph and finding the total XOR</span>
            graph[i] = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
            tot ^= arr[i];
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge : edges) {
            <span class="hljs-comment">// adding the edges</span>
            <span class="hljs-keyword">int</span> u = edge[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">int</span> v = edge[<span class="hljs-number">1</span>];
            graph[u].add(v);
            graph[v].add(u);
        }
        ans = Integer.MAX_VALUE;
        dfs(<span class="hljs-number">0</span>, graph, arr, -<span class="hljs-number">1</span>, tot);
        <span class="hljs-keyword">return</span> ans;
    }
}
</code></pre>
<p><strong>Explain:</strong></p>
<p>nope.</p>
<p><strong>Complexity:</strong></p>
<ul>
<li>Time complexity : O(n).</li>
<li>Space complexity : O(n).</li>
</ul></article></main><footer><a href="https://github.com/curest0x1021/Leetcode-Solution" target="_blank"><img src="https://curest0x1021.github.io/Leetcode-Solution/static/img/github.png" alt="github"/></a></footer></body></html>